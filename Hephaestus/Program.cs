using Mutagen.Bethesda;
using Mutagen.Bethesda.FormKeys.SkyrimSE;
using Mutagen.Bethesda.Plugins;
using Mutagen.Bethesda.Plugins.Aspects;
using Mutagen.Bethesda.Skyrim;
using Mutagen.Bethesda.Synthesis;

namespace Hephaestus
{
    // To do
    // Find a way to break down items without losing them (for artifacts and the like, maybe make a item to fragment cobj option that looks for a specific level in smithing?)
    // Maybe add a merchant option to trainers/blacksmiths that lets you buy schematics?
    // copy keywords from primary cobj to book/fragment cobj
    // make notes be per material per part (steel harness, orcish blade, leather handle, etc)

    public class Program
    {
        static Lazy<Settings> _settings = null!;
        public static Settings settings => _settings.Value;

        public static async Task<int> Main(string[] args)
        {
            // Run the patcher
            return await SynthesisPipeline.Instance
                .AddPatch<ISkyrimMod, ISkyrimModGetter>(RunPatch)
                .SetTypicalOpen(GameRelease.SkyrimSE, "Hephaestus.esp")
                .SetAutogeneratedSettings("Settings", "settings.json", out _settings)
                .Run(args);
        }

        private static void RunPatch(IPatcherState<ISkyrimMod, ISkyrimModGetter> state)
        {
            //Declare base vars and dictionaries
            char[] vowels = { 'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U' };
            Dictionary<FormKey, List<FormKey>> itemCOBJs = new();
            Dictionary<FormKey, List<FormKey>> itemLVLIs = new();
            Dictionary<FormKey, FormKey> itemBOOK = new();
            Dictionary<FormKey, FormKey> itemBOOKPlayer = new();
            Dictionary<FormKey, FormKey> itemBOOKFragment = new();
            Dictionary<FormKey, Dictionary<String, FormKey>> bookLVLIs = new();

            var bookModelLib = new Dictionary<FormKey, Model>()
            {
                {
                    Skyrim.Static.HighPolyJournal.FormKey,
                    new Model() { File = "Clutter/Books/JournalLowPoly01.nif" }
                },
                {
                    Skyrim.Static.HighPolyJournal02.FormKey,
                    new Model() { File = "Clutter/Books/JournalLowPoly02.nif" }
                },
                {
                    Skyrim.Static.HighPolyJournal03.FormKey,
                    new Model() { File = "Clutter/Books/JournalLowPoly03.nif" }
                }
            };

            var bookFragmentModelLib = new Dictionary<FormKey, Model>()
            {
                {
                    Skyrim.Static.HighPolyNote.FormKey,
                    new Model() { File = "Clutter/Books/Note.nif" }
                },
                {
                    Skyrim.Static.HighPolyNote02.FormKey,
                    new Model() { File = "Clutter/Books/Note02.nif" }
                },
                {
                    Skyrim.Static.HighPolyNote03.FormKey,
                    new Model() { File = "Clutter/Books/Note03.nif" }
                },
                {
                    Skyrim.Static.HighPolyNote04.FormKey,
                    new Model() { File = "Clutter/Books/Note04.nif" }
                }
            };

            // NPC name lists
            List<string> NPCNames = new();

            // Add customized names to pool
            if (settings.LovedOnesName.Count != 0)
            {
                NPCNames = NPCNames.Concat(settings.LovedOnesName).ToList();
            }

            List<string> BlacksmithNPCNames =
                new()
                {
                    // Vanilla NPCs
                    "Adrianne Avenicci",
                    "Alvor",
                    "Arnskar Ember-Master",
                    "Asbjorn Fire-Tamer",
                    "Balimund",
                    "Baldor Iron-Shaper",
                    "Beirand",
                    "Dushnamub",
                    "Elrindir",
                    "Eorlund Gray-Mane",
                    "Filnjar",
                    "Fihada",
                    "Gharol",
                    "Ghorza gra-Bagol",
                    "Glover Mallory",
                    "Gunmar",
                    "Hestla",
                    "Lod",
                    "Moth gro-Bagol",
                    "Oengul War-Anvil",
                    "Rustleif",
                    "Shuftharz",
                    "Syndus",
                    "Ulfberth War-Bear",
                    "Vanryth Gatharian",
                    "Garakh",
                };

            List<string> NordNPCNames =
                new()
                {
                    // Nord
                    "Bjorn",
                    "Freya",
                    "Leif",
                    "Sigrid",
                    "Erik",
                    "Astrid",
                    "Magnus",
                    "Ingrid",
                    "Gunnar",
                    "Elsa",
                    "Ragnar",
                    "Kara",
                    "Hakon",
                    "Frida",
                    "Sven",
                    "Lena",
                    "Jarl",
                    "Helga",
                    "Torvald",
                    "Rosa",
                    "Olaf",
                    "Ida",
                    "Ulfrik",
                    "Solveig",
                    "Harald",
                    "Kirsten",
                    "Yngvar",
                    "Elin",
                    "Sten",
                    "Marta",
                };

            List<string> HumanNPCNames =
                new()
                {
                    // Breton
                    "Alain",
                    "Eloise",
                    "Gilbert",
                    "Melisande",
                    "Bertrand",
                    "Cecile",
                    "Henri",
                    "Rosalie",
                    "Damien",
                    "Fleur",
                    "Jules",
                    "Sylvie",
                    "Etienne",
                    "Isabelle",
                    "Laurent",
                    "Viviane",
                    "Gaston",
                    "Juliette",
                    "Marc",
                    "Yvette",
                    "Hugo",
                    "Lucie",
                    "Olivier",
                    "Zoe",
                    "Leon",
                    "Margot",
                    "Pierre",
                    "Adele",
                    "Remy",
                    "Camille",
                    // Imperial
                    "Antonius",
                    "Claudia",
                    "Lucius",
                    "Valeria",
                    "Brutus",
                    "Diana",
                    "Marcus",
                    "Aurelia",
                    "Cassius",
                    "Flavia",
                    "Octavius",
                    "Cornelia",
                    "Decimus",
                    "Julia",
                    "Quintus",
                    "Livia",
                    "Felix",
                    "Larissa",
                    "Sergius",
                    "Sabina",
                    "Gaius",
                    "Nerissa",
                    "Titus",
                    "Veronica",
                    "Horatius",
                    "Prisca",
                    "Vitus",
                    "Cynthia",
                    "Lucianus",
                    "Fabia",
                    // Redguard
                    "Cyrus",
                    "Farah",
                    "Malik",
                    "Zara",
                    "Alik",
                    "Hana",
                    "Rihad",
                    "Laila",
                    "Basim",
                    "Jamila",
                    "Sahan",
                    "Nura",
                    "Darius",
                    "Nadia",
                    "Tahir",
                    "Rana",
                    "Fares",
                    "Samira",
                    "Yasir",
                    "Amira",
                    "Hakim",
                    "Leila",
                    "Zayn",
                    "Aisha",
                    "Karim",
                    "Nadya",
                    "Jabari",
                    "Zahra",
                    "Omar",
                    "Salma",
                };

            List<string> ElfNPCNames =
                new()
                {
                    // Altmer
                    "Calion",
                    "Elenwen",
                    "Farenir",
                    "Tandilwe",
                    "Andilir",
                    "Galerion",
                    "Ilenir",
                    "Nalirelwe",
                    "Carandil",
                    "Heculoa",
                    "Larethor",
                    "Ondolemar",
                    "Elandora",
                    "Imedril",
                    "Nalanya",
                    "Rinyde",
                    "Fasendil",
                    "Lathenil",
                    "Ohtesse",
                    "Taranis",
                    // Bosmer
                    "Camoran",
                    "Elara",
                    "Fargoth",
                    "Nara",
                    "Anoriath",
                    "Elsweyr",
                    "Finoriell",
                    "Niruin",
                    "Aranias",
                    "Eranas",
                    "Gaenor",
                    "Ondrevel",
                    "Arthcamu",
                    "Erthor",
                    "Gilraen",
                    "Sinderion",
                    "Barenziah",
                    "Faendal",
                    "Glarthir",
                    "Tharayya",
                    // Dunmer
                    "Adryn",
                    "Dratha",
                    "Neloth",
                    "Voryn",
                    "Almalexia",
                    "Drelasa",
                    "Nerevar",
                    "Vivec",
                    "Aryon",
                    "Dren",
                    "Nibani",
                    "Zainab",
                    "Baladas",
                    "Drilu",
                    "Nix-Hound",
                    "Zanummu",
                    "Barenziah",
                    "Drinar",
                    "Orvas",
                    "Zekiel",
                    "Brara",
                    "Drovas",
                    "Ralen",
                    "Zula"
                };

            List<string> OrcNPCNames =
                new()
                {
                    // Orc
                    "Balagog",
                    "Ghorza",
                    "Kharag",
                    "Shuftharz",
                    "Bazrag",
                    "Gortwog",
                    "Kurog",
                    "Urag",
                    "Bolar",
                    "Graufang",
                    "Lazgara",
                    "Urok",
                    "Borgakh",
                    "Gularzob",
                    "Lob",
                    "Ushug",
                    "Bugak Gro-Dhalug",
                    "Mauhulakh",
                    "Yamarz",
                    "Burguk Gro-Nagorm",
                    "Mazoga",
                    "Yashnag"
                };

            List<string> BeastNPCNames =
                new()
                {
                    // Argonian
                    "Deel-Jeen",
                    "Jaree-Ra",
                    "Scales-Like-Silver",
                    "Veezara",
                    "Derkeethus",
                    "Jee-Lar",
                    "Sees-All-Colors",
                    "Vistha-Kai",
                    "Eyes-of-Steel",
                    "Jorunn",
                    "Skald-King",
                    "Shahvee",
                    "Wamasu",
                    "From-Deepest-Fathoms",
                    "Keerava",
                    "Shellback",
                    "Xukas",
                    "Geel-Lah",
                    "Keshu",
                    "Black-Fin",
                    "Sings-With-Reed",
                    "Zhasim",
                    // Khajiit
                    "Dar'jargo",
                    "Ra'jirra",
                    "S'rendarr",
                    "Dar'Ma",
                    "Jo'Ren-Dar",
                    "Rajhin",
                    "S'rashi",
                    "Daro'Raaji",
                    "Kharjo",
                    "Rasha",
                    "S'rathra",
                    "Dro'Zira",
                    "Khayla",
                    "Razum-dar",
                    "Shazah",
                    "Dro'Zirr",
                    "Khunzar-ri",
                    "Ri'saad",
                    "Shazgob",
                    "Elsweyr",
                    "Kiergo",
                    "Ri'Zakar"
                };

            List<string> DwemerNPCNames =
                new()
                {
                    "Bthuand",
                    "Dhark",
                    "Dumac",
                    "Gharen",
                    "Kagrenac",
                    "Mzunchend",
                    "Nchunak",
                    "Rkungthunch",
                    "Sthovin",
                    "Yagrum",
                    "Barenziah",
                    "Dratha",
                    "Lannessa",
                    "Neransi",
                    "Zula"
                };

            Console.WriteLine(String.Empty);
            Console.WriteLine("=================================================");
            Console.WriteLine(String.Empty);
            Console.WriteLine("Building cache ...");
            Console.WriteLine(String.Empty);

            // Enumerate through COBJs and save the data for later for the items that have names and values, for which the COBJ has a whitelisted keyword and which are present in at least one leveled list
            foreach (
                IConstructibleObjectGetter baseCOBJ in state.LoadOrder.PriorityOrder
                    .ConstructibleObject()
                    .WinningOverrides()
            )
            {
                // Sanity checks to skip unnecessary processing
                if (
                    baseCOBJ.Items == null
                    || !settings.BenchSettings.Any(
                        e => e.BenchKeyword.FormKey == baseCOBJ.WorkbenchKeyword.FormKey
                    )
                    || !baseCOBJ.CreatedObject.TryResolve(state.LinkCache, out var createdItem)
                )
                    continue;

                // Skip if in blacklist
                if (settings.itemBlacklist == null || settings.itemBlacklist.Contains(createdItem))
                    continue;

                // Skip if item value can't be grabbed
                if (createdItem is not IWeightValueGetter && createdItem is not IWeaponGetter)
                    continue;

                // Check if there are any LVLIs that this item is present in
                foreach (
                    var baseLVLI in state.LoadOrder.PriorityOrder.LeveledItem().WinningOverrides()
                )
                {
                    if (baseLVLI.Entries == null)
                        continue;
                    if (baseLVLI.Entries.Any(e => e.Data?.Reference.FormKey == createdItem.FormKey))
                    {
                        if (!itemLVLIs.ContainsKey(createdItem.FormKey))
                            itemLVLIs.Add(createdItem.FormKey, new List<FormKey>());

                        if (!itemLVLIs[createdItem.FormKey].Contains(baseLVLI.FormKey))
                            itemLVLIs[createdItem.FormKey].Add(baseLVLI.FormKey);
                    }
                }

                // if no relevant LVLIs, skip item early
                if (!itemLVLIs.ContainsKey(createdItem.FormKey))
                    continue;

                // add COBJ now since it's already passed the LVLI check
                if (!itemCOBJs.ContainsKey(createdItem.FormKey))
                    itemCOBJs.Add(createdItem.FormKey, new List<FormKey>());
                itemCOBJs[createdItem.FormKey].Add(baseCOBJ.FormKey);
            }

            Console.WriteLine(String.Empty);
            Console.WriteLine("=================================================");
            Console.WriteLine(String.Empty);
            Console.WriteLine("Assigning item types and prepping things ...");

            foreach (var createdItemFormKey in itemCOBJs.Keys)
            {
                // Pull created item
                if (
                    !state.LinkCache.TryResolve<IItemGetter>(
                        createdItemFormKey,
                        out var createdItem
                    )
                    || createdItem is not INamedGetter createdItemName
                    || createdItem is not IKeywordedGetter createdItemKeywords
                )
                    continue;

                if (settings.ShowDebugLogs)
                {
                    Console.WriteLine(String.Empty);
                    Console.WriteLine("=======================");
                    Console.WriteLine(String.Empty);
                    Console.WriteLine($"Found {createdItemName.Name} ...");
                }
                else
                    Console.WriteLine($"Patching for {createdItemName.Name} ...");

                // Deterministic seed
                var random = new Random(createdItem.FormKey.ID.GetHashCode());

                // Base Object
                string? objName = createdItemName.Name;
                string? objEditorID = createdItem.EditorID;
                uint objValue;
                string? objType = "Misc";

                if (createdItem is IWeightValueGetter createdItemValue)
                    objValue = createdItemValue.Value;
                else if (createdItem is IWeaponGetter createdWeapon)
                    objValue = createdWeapon.BasicStats?.Value ?? 10;
                else
                    continue;

                // Book variables
                Book book;
                Book bookPlayer;
                Book bookFragment;

                // Randomize book model
                var bookModelSetKey = bookModelLib.Keys.ElementAt(
                    (int)Math.Round((bookModelLib.Count - 1) * (float)random.NextDouble())
                );
                if (!state.LinkCache.TryResolve<IStaticGetter>(bookModelSetKey, out var bookStatic))
                    continue;

                // Randomize fragment model
                var bookFragmentModelSetKey = bookFragmentModelLib.Keys.ElementAt(
                    (int)Math.Round((bookFragmentModelLib.Count - 1) * (float)random.NextDouble())
                );
                if (
                    !state.LinkCache.TryResolve<IStaticGetter>(
                        bookFragmentModelSetKey,
                        out var bookFragmentStatic
                    )
                )
                    continue;

                // Initialize other
                string? requiredItems = String.Empty;
                string? aAn;
                if (objName?.IndexOfAny(vowels) == 0)
                    aAn = "an ";
                else if (
                    (createdItemFormKey == Skyrim.MiscItem.LeatherStrips.FormKey)
                    || (createdItemFormKey == Skyrim.MiscItem.Leather01.FormKey)
                )
                    aAn = "";
                else
                    aAn = "a ";

                // Assigning item types
                switch (createdItem)
                {
                    case IWeaponGetter:
                        objType = "Weapon";
                        break;
                    case IIngestibleGetter:
                        objType = "Cooking";
                        break;
                    case IArmorGetter armorObj:
                        var flagToCheck = armorObj.BodyTemplate;
                        if (flagToCheck == null)
                            continue;
                        switch (flagToCheck.FirstPersonFlags)
                        {
                            case BipedObjectFlag.Hands
                            or BipedObjectFlag.Feet:
                                aAn = "a pair of ";
                                break;
                            case BipedObjectFlag.Amulet
                            or BipedObjectFlag.Ring:
                                objType = "Jewelry";
                                break;
                            default:
                                objType = "Armor";
                                break;
                        }
                        if (armorObj.EquipmentType.FormKey == Skyrim.EquipType.Shield.FormKey)
                        {
                            objType = "Shield";
                        }
                        break;
                }

                if (settings.ShowDebugLogs)
                {
                    Console.WriteLine(String.Empty);
                    Console.WriteLine($"Creating {objName} schematics and patching COBJs ...");
                }

                foreach (FormKey cobjFormKey in itemCOBJs[createdItemFormKey])
                {
                    // Define COBJ
                    if (
                        !state.LinkCache.TryResolve<IConstructibleObjectGetter>(
                            cobjFormKey,
                            out var cobj
                        )
                    )
                        continue;

                    // Set values based on bench
                    var curBenchSettings = settings.BenchSettings[
                        settings.BenchSettings.FindIndex(
                            e => e.BenchKeyword.FormKey == cobj.WorkbenchKeyword.FormKey
                        )
                    ];
                    string objBench = curBenchSettings.objBenchName ?? "crafting bench";
                    string schematicType = curBenchSettings.schematicTypeName ?? "Schematic";
                    string processName = curBenchSettings.processName ?? "craft";
                    string processNameCont = $"{processName}ing";

                    if (vowels.Any(e => e == processName[processName.Length - 1]))
                        processNameCont = $"{processName.Substring(0, processName.Length - 1)}ing";

                    if (cobj.Items == null)
                        continue;
                    foreach (var reqItem in cobj.Items)
                    {
                        if (!reqItem.Item.Item.TryResolve(state.LinkCache, out var reqItemObj))
                            continue;
                        if (reqItemObj is not INamedGetter namedItem)
                            continue;
                        requiredItems += $"{namedItem.Name}\n";
                    }
                    ;

                    // Building the flavour text
                    if (!itemBOOK.ContainsKey(createdItem.FormKey))
                    {
                        // Define how many times an item needs to be broken down
                        int min = 5;
                        int max = 10;
                        uint noteToSchematicRatio = (uint)
                            Math.Max(Math.Round(min + (max - min) * (float)random.NextDouble()), 1);

                        // Name generation for schematic data
                        if (createdItemKeywords.Keywords != null)
                        {
                            List<String> equipment =
                                new() { "Armor", "Weapon", "Shield", "Jewelry" };

                            // if it's equipment, generate based on races, otherwise don't
                            if (equipment.Contains(objType))
                            {
                                if (
                                    createdItemKeywords.Keywords.Contains(
                                        Skyrim.Keyword.WeapMaterialElven
                                    )
                                    || createdItemKeywords.Keywords.Contains(
                                        Skyrim.Keyword.ArmorMaterialElvenGilded
                                    )
                                    || createdItemKeywords.Keywords.Contains(
                                        Skyrim.Keyword.ArmorMaterialElven
                                    )
                                    || createdItemKeywords.Keywords.Contains(
                                        Skyrim.Keyword.WeapMaterialFalmer
                                    )
                                    || createdItemKeywords.Keywords.Contains(
                                        Skyrim.Keyword.WeapMaterialFalmerHoned
                                    )
                                )
                                {
                                    NPCNames = ElfNPCNames;
                                }
                                else if (
                                    createdItemKeywords.Keywords.Contains(
                                        Skyrim.Keyword.WeapMaterialOrcish
                                    )
                                    || createdItemKeywords.Keywords.Contains(
                                        Skyrim.Keyword.ArmorMaterialOrcish
                                    )
                                )
                                {
                                    NPCNames = OrcNPCNames;
                                }
                                else if (
                                    createdItemKeywords.Keywords.Contains(
                                        Skyrim.Keyword.WeapMaterialDwarven
                                    )
                                    || createdItemKeywords.Keywords.Contains(
                                        Skyrim.Keyword.ArmorMaterialDwarven
                                    )
                                )
                                {
                                    NPCNames = DwemerNPCNames;
                                }
                                else if (
                                    createdItemKeywords.Keywords.Contains(
                                        Skyrim.Keyword.WeapMaterialDraugr
                                    )
                                    || createdItemKeywords.Keywords.Contains(
                                        Skyrim.Keyword.WeapMaterialDraugrHoned
                                    )
                                    || createdItemKeywords.Keywords.Contains(
                                        Skyrim.Keyword.ArmorMaterialDwarven
                                    )
                                )
                                {
                                    NPCNames = NPCNames.Concat(NordNPCNames).ToList();
                                }
                                else
                                {
                                    NPCNames = NPCNames
                                        .Concat(NordNPCNames)
                                        .Concat(HumanNPCNames)
                                        .Concat(BeastNPCNames)
                                        .Concat(BlacksmithNPCNames)
                                        .ToList();
                                }
                            }
                            else
                            {
                                NPCNames = NPCNames
                                    .Concat(NordNPCNames)
                                    .Concat(HumanNPCNames)
                                    .Concat(BeastNPCNames)
                                    .Concat(ElfNPCNames)
                                    .Concat(OrcNPCNames)
                                    .Concat(DwemerNPCNames)
                                    .ToList();
                            }
                        }
                        // create a new book
                        book = state.PatchMod.Books.AddNew();

                        // Set the book properties
                        book.EditorID = $"{objEditorID}_{schematicType}";
                        book.Name = $"{objType} {schematicType}: {objName}";
                        book.Description =
                            $"A {schematicType.ToLower()} created by {NPCNames[random.Next(NPCNames.Count)]}. It details the process of {processNameCont} {aAn}{objName}.";
                        book.Value = objValue * (noteToSchematicRatio + 2);
                        book.Weight = 0.25f;
                        book.Model = bookModelLib[bookModelSetKey];
                        book.InventoryArt = new FormLinkNullable<IStaticGetter>(bookStatic);
                        book.ObjectBounds = bookStatic.ObjectBounds.DeepCopy();
                        book.Type = Book.BookType.BookOrTome;
                        book.PickUpSound = new FormLinkNullable<ISoundDescriptorGetter>(
                            Skyrim.SoundDescriptor.ITMNoteUp.FormKey
                        );
                        book.Keywords = new Noggog.ExtendedList<IFormLinkGetter<IKeywordGetter>>();
                        book.Keywords.Add(Skyrim.Keyword.VendorItemRecipe);

                        // Formatting book contents
                        List<string> flavourText =
                            new()
                            {
                                $"This {schematicType.ToLower()} looks like the notes of a madman, though I can somewhat decypher it. It seems to detail the process of {processNameCont} {aAn}{objName} at a {objBench}.",
                                $"This {schematicType.ToLower()} seems to have been teared off from someone's journal. It seems to explain the process of {processNameCont} {aAn}{objName} at a {objBench}.",
                                $"This {schematicType.ToLower()} goes into great detail on the steps of {processNameCont} {aAn}{objName} at a {objBench}.",
                                $"This {schematicType.ToLower()} contains the secrets to {processNameCont} {aAn}{objName} at a {objBench}.",
                                $"This {schematicType.ToLower()} is filled with scribbles and notes on the steps of {processNameCont} {aAn}{objName} at a {objBench}.",
                                $"This {schematicType.ToLower()} still has some stains of blood on it, it describes the process of {processNameCont} {aAn}{objName} at a {objBench}."
                            };

                        // Formatting book contents
                        List<string> ArmorflavourText =
                            new()
                            {
                                $"This {schematicType.ToLower()} seems to have been written by a smith apprentice, from the looks of it it describes how to {processName} {aAn}{objName} at a {objBench}.",
                                $"This {schematicType.ToLower()} seems to have been drawn by a designer. It shows the steps of {processNameCont} {aAn}{objName} at a {objBench}. I can see the style and the flair of this piece of armor, I wonder how it looks.",
                                $"This {schematicType.ToLower()} seems to have been written by a traveler. It narrates the steps of {processNameCont} {aAn}{objName} at a {objBench}. I can see the experience and the wisdom of this piece of armor, I wonder what it has seen.",
                                $"This {schematicType.ToLower()} seems to have been uttered by a priest. It blesses the steps of {processNameCont} {aAn}{objName} at a {objBench}. I can see the faith and the grace of this piece of armor, I wonder what it protects.",
                                $"This {schematicType.ToLower()} seems to have been drawn by a designer. It shows the steps of {processNameCont} {aAn}{objName} at a {objBench}. I can see the style and the flair of this piece of armor, I wonder how it looks.",
                                $"To create {aAn}{objName}, I will need this {schematicType.ToLower()} and access to a {objBench}. The {objName} is a rare piece of armor that can be found only in certain places. The {processNameCont} method involves using special skills and tools to create a complex and unique design.",
                                $"This {schematicType.ToLower()} seems to have been written by a master. It instructs the steps of {processNameCont} {aAn}{objName} at a {objBench}. I can see the skill and the expertise of this piece of armor, I wonder how it performs.",
                                $"This {schematicType.ToLower()} is written as a riddle. It puzzles the steps of {processNameCont} {aAn}{objName} at a {objBench}. I can see the mystery and the enigma of this piece of armor, I wonder what it hides.",
                                $"This {schematicType.ToLower()} seems to have been created by an artist. It depicts the steps of {processNameCont} {aAn}{objName} at a {objBench}. I can see the color and the expression of this piece of armor, I wonder how it inspires.",
                            };

                        // Formatting book contents
                        List<string> WeaponflavourText =
                            new()
                            {
                                $"This {schematicType.ToLower()} seems to belong to a famous craftsman. It reveals the secrets of {processNameCont} {aAn}{objName} at a {objBench}. I can see the intricate details and the careful instructions that go into making such a masterpiece.",
                                $"This {schematicType.ToLower()} looks like it was written in a hurry. It shows the basics of {processNameCont} {aAn}{objName} at a {objBench}. I can tell that the writer was not very experienced or skilled, but they managed to create something useful.",
                                $"This {schematicType.ToLower()} seems to have some strange symbols and diagrams on it. It describes the process of {processNameCont} {aAn}{objName} at a {objBench}. I can sense some magic and mystery behind this weapon, I wonder what it can do.",
                                $"This {schematicType.ToLower()} seems to have been stolen from a royal vault. It explains the steps of {processNameCont} {aAn}{objName} at a {objBench}. I can see the quality and the elegance of this weapon, I bet it belongs to someone important.",
                                $"This {schematicType.ToLower()} seems to have been passed down for generations. It tells the story of {processNameCont} {aAn}{objName} at a {objBench}. I can feel the history and the legacy of this weapon, I wonder who wielded it before me.",
                                $"This {schematicType.ToLower()} seems to have been written by someone who just learned the craft. It outlines the steps of {processNameCont} {aAn}{objName} at a {objBench}. I can see the enthusiasm and the creativity of this weapon, I hope it works as intended.",
                                $"This {schematicType.ToLower()} seems to have been made by a child. It illustrates the process of {processNameCont} {aAn}{objName} at a {objBench}. I can see the imagination and the fun of this weapon, I wonder what inspired it.",
                                $"This {schematicType.ToLower()} seems to have been used as a weapon itself. It depicts the steps of {processNameCont} {aAn}{objName} at a {objBench}. I can see the violence and the madness of this weapon, I hope it was worth it.",
                                $"This {schematicType.ToLower()} seems to have been hidden for a long time. It reveals the secrets of {processNameCont} {aAn}{objName} at a {objBench}. I can see the wisdom and the knowledge of this weapon, I wonder what secrets it holds.",
                                $"This {schematicType.ToLower()} seems to have been made by a professional. It shows the steps of {processNameCont} {aAn}{objName} at a {objBench}. I can see the precision and the efficiency of this weapon, I admire the skill behind it.",
                                $"This {schematicType.ToLower()} seems to have been ripped from a book. It explains the steps of {processNameCont} {aAn}{objName} at a {objBench}. I can see the complexity and the diversity of this weapon, I wonder how it works.",
                                $"This {schematicType.ToLower()} seems to have been written by a rogue. It conceals the steps of {processNameCont} {aAn}{objName} at a {objBench}. I can see the stealth and the cunning of this weapon, I wonder who it was written for.",
                                $"This {schematicType.ToLower()} seems to have been salvaged from a fire. It preserves the steps of {processNameCont} {aAn}{objName} at a {objBench}. I can see the damage and the danger of this weapon, I hope it is not too late.",
                                $"This {schematicType.ToLower()} seems to have been used as a wipe. It stains the steps of {processNameCont} {aAn}{objName} at a {objBench}. I can see the dirt and the grime of this weapon, I hope it is still usable.",
                                $"This {schematicType.ToLower()} seems to have been thrown away. It discards the steps of {processNameCont} {aAn}{objName} at a {objBench}. I can see the failure and the frustration of this weapon, I wonder what went wrong.",
                                $"This {schematicType.ToLower()} is a musical sheet, it seems to have been composed by a bard. It sings the steps of {processNameCont} {aAn}{objName} at a {objBench}. I can hear the melody and the rhythm of this weapon, I wonder how it sounds.",
                                $"This {schematicType.ToLower()} is a map, it seems to have been drawn by an explorer. It marks the steps of {processNameCont} {aAn}{objName} at a {objBench}. I can see the adventure and the discovery of this weapon, I wonder where it leads.",
                                $"This {schematicType.ToLower()} is a poem, it seems to have been written by a lover. It praises the steps of {processNameCont} {aAn}{objName} at a {objBench}. I can feel the emotion and the beauty of this weapon, I wonder who it is for.",
                                $"This {schematicType.ToLower()} is a joke, it seems to have been told by a jester. It mocks the steps of {processNameCont} {aAn}{objName} at a {objBench}. I can see the humor and the irony of this weapon, I wonder if it is funny."
                            };

                        // Formatting book contents
                        List<string> ShieldflavourText =
                            new()
                            {
                                $"This {schematicType.ToLower()} reveals the secrets and arts of the craft, explaining the advanced steps to craft {aAn}{objName} using a {objBench}. This shield is a legendary item, only the worthy can obtain it. It requires mastering the {processNameCont} technique to create an extraordinary and powerful design.",
                                $"A soldier must have written this {schematicType.ToLower()}, it states the steps of {processNameCont} {aAn}{objName} at a {objBench} with duty and loyalty. I wonder who this shield serves, it must be very reliable.",
                                $"I will need this {schematicType.ToLower()} and access to a {objBench} to make {aAn}{objName}. This shield is a common item, it can be used for various purposes. I will need to work with the available materials to create a simple and functional design, following the {processNameCont} technique.",
                                $"A traveler must have written this {schematicType.ToLower()}, it narrates the steps of {processNameCont} {aAn}{objName} at a {objBench} with experience and wisdom. I wonder what this shield has seen, it must have been through many adventures.",
                                $"A priest must have uttered this {schematicType.ToLower()}, it blesses the steps of {processNameCont} {aAn}{objName} at a {objBench} with faith and grace. I wonder what this shield protects, it must be very sacred.",
                                $"A Companion must have made this {schematicType.ToLower()}, it urges the steps of {processNameCont} {aAn}{objName} at a {objBench} with courage. I wonder how this shield fights, it must be very brave.",
                                $"A artist must have created this {schematicType.ToLower()}, it depicts the steps of {processNameCont} {aAn}{objName} at a {objBench} with color and expression. I wonder how this shield inspires, it must be very beautiful.",
                                $"A collector must have made this {schematicType.ToLower()}, it records the steps of {processNameCont} {aAn}{objName} at a {objBench} with rarity and value. I wonder how this shield shines, it must be very precious.",
                                $"A witch must have written this {schematicType.ToLower()}, it twists the steps of {processNameCont} {aAn}{objName} at a {objBench} with evil and malice. I wonder how this shield hurts, it must be very dangerous."
                            };

                        // Formatting book contents
                        List<string> CookingflavourText =
                            new()
                            {
                                $"This {schematicType.ToLower()} must've been taken out of a cookbook, it lists the steps of {processNameCont} {aAn}{objName} at a {objBench}. This {objName} looks delicious, it must be very tasty. I can smell the aroma and the flavor of this dish, I can't wait to try it.",
                                $"To prepare {aAn}{objName}, I will need this {schematicType.ToLower()} and access to a {objBench}. This {objName} is a traditional dish, it has been passed down for generations. I will need to use fresh ingredients and follow the {processNameCont} method to make it. I can feel the warmth and the comfort of this dish, it reminds me of home.",
                                $"This {schematicType.ToLower()} reveals the secrets of {processNameCont} {aAn}{objName} using a {objBench}. This {objName} is a exotic dish, it comes from a faraway land. I will need to master the skills and the tools to make it. I can see the spice and the zest of this dish, it makes me curious.",
                                $"Someone must have left this {schematicType.ToLower()} on a table for a long time, it's quite stained. It outlines the steps of {processNameCont} {aAn}{objName} at a {objBench}. This {objName} looks simple, but it has a hidden twist. I can taste the sweetness and the sourness of this dish, it surprises me.",
                                $"I will need this {schematicType.ToLower()} and access to a {objBench} to cook {aAn}{objName}. This {objName} is a healthy dish, it is good for Ir body and mind. I will need to use organic ingredients and follow the {processNameCont} technique to make it. I can feel the energy and the vitality of this dish, it makes me happy.",
                                $"This {schematicType.ToLower()} teaches I how to {processName} {aAn}{objName} using a {objBench}. This {objName} is a festive dish, it is perfect for celebrations and parties. I will need to use rich ingredients and follow the {processNameCont} method to make it. I can hear the laughter and the joy of this dish, it makes me festive.",
                                $"To {processNameCont} {aAn}{objName}, I will need this {schematicType.ToLower()} and access to a {objBench}. This {objName} is a special dish, it is made with love and care. I will need to use quality ingredients and follow the {processNameCont} technique to make it. I can feel the friendship and the generosity of this dish, it makes me grateful.",
                                $"This {schematicType.ToLower()} reveals the steps of {processNameCont} {aAn}{objName} at a {objBench}. This {objName} is a ancient dish, it has a long history and tradition. I will need to use rare ingredients and master the {processNameCont} technique to make it. I can see the wisdom and the knowledge of this dish, it makes me curious.",
                                $"To {processNameCont} {aAn}{objName}, I will need this {schematicType.ToLower()} and access to a {objBench}. This {objName} is a mysterious dish, it has a secret ingredient and a hidden effect. I will need to use unknown ingredients and follow the {processNameCont} method to make it. I can taste the mystery and the magic of this dish, it makes me adventurous.",
                                $"This {schematicType.ToLower()} tells I how to {processName} {aAn}{objName} at a {objBench}. This {objName} is a personal dish, it is Ir own creation and invention. I will need to use Ir favorite ingredients and follow Ir own {processNameCont} technique to make it. I can see the creativity and the expression of this dish, it makes me proud.",
                                $"This {schematicType.ToLower()} shows me how to {processName} {aAn}{objName} using a {objBench}. This {objName} is a delicious dish, it is good for any occasion. I will need to use fresh ingredients and follow the {processNameCont} method to make it. I can smell the aroma and the flavor of this dish, it makes me hungry.",
                                $"I will need this {schematicType.ToLower()} and access to a {objBench} to {processNameCont} {aAn}{objName}. This {objName} is a traditional dish, it has been passed down for generations. I will need to use authentic ingredients and follow the {processNameCont} technique to make it. I can feel the warmth and the comfort of this dish, it reminds me of home.",
                                $"This {schematicType.ToLower()} explains the steps of {processNameCont} {aAn}{objName} at a {objBench}. This {objName} is a exotic dish, it comes from a faraway land. I will need to master the skills and the tools to make it. I can see the spice and the zest of this dish, it makes me curious.",
                                $"I will need this {schematicType.ToLower()} and access to a {objBench} to cook {aAn}{objName}. This {objName} is a healthy dish, it is good for your body and mind. I will need to use organic ingredients and follow the {processNameCont} technique to make it. I can feel the energy and the vitality of this dish, it makes me happy.",
                                $"This {schematicType.ToLower()} instructs me how to {processName} {aAn}{objName} at a {objBench}. This {objName} is a festive dish, it is perfect for celebrations and parties. I will need to use rich ingredients and follow the {processNameCont} method to make it. I can hear the laughter and the joy of this dish, it makes me festive.",
                            };

                        // Formatting book contents
                        List<string> JewelryflavourText =
                            new()
                            {
                                $"This {schematicType.ToLower()} shows me how to get started on {processNameCont} {aAn}{objName} using a {objBench}. This {objName} is a beautiful piece of jewelry, it is good for any occasion. I will need to use shiny materials and follow the {processNameCont} method to make it. I can see the sparkle and the elegance of this piece, it makes me dazzled.",
                                $"I will need this {schematicType.ToLower()} and access to a {objBench} to get started on {processNameCont} {aAn}{objName}. This {objName} is a rare piece of jewelry, it can only be found in certain places. I will need to use precious materials and follow the {processNameCont} technique to make it. I can feel the value and the luxury of this piece, it makes me rich.",
                                $"This {schematicType.ToLower()} explains the steps of {processNameCont} {aAn}{objName} at a {objBench}. This {objName} is a magical piece of jewelry, it has a special power and effect. I will need to master the skills and the tools to make it. I can see the magic and the mystery of this piece, it makes me curious.",
                                $"This {schematicType.ToLower()} contains the instructions on {processNameCont} {aAn}{objName} at a {objBench}. This {objName} is a special piece of jewelry, it is made with love and care. I will need to use quality materials and follow the {processNameCont} method to make it. I can feel the friendship and the generosity of this piece, it makes me grateful.",
                                $"This {schematicType.ToLower()} teaches me the way of {processNameCont} {aAn}{objName} using a {objBench}. This {objName} is a ancient piece of jewelry, it has a long history and tradition. I will need to use rare materials and master the {processNameCont} technique to make it. I can see the wisdom and the knowledge of this piece, it makes me curious.",
                                $"To get started on {processNameCont} {aAn}{objName}, I will need this {schematicType.ToLower()} and access to a {objBench}. This {objName} is a exotic piece of jewelry, it comes from a faraway land. I will need to use unique materials and follow the {processNameCont} method to make it. I can see the spice and the zest of this piece, it makes me adventurous.",
                                $"This {schematicType.ToLower()} reveals the secrets of {processNameCont} {aAn}{objName} at a {objBench}. This {objName} is a legendary piece of jewelry, only the worthy can obtain it. I will need to use special materials and master the secrets and arts of the craft to make it. I can see the glory and the honor of this piece, it makes me proud.",
                                $"To craft {aAn}{objName}, I will need this {schematicType.ToLower()} and access to a {objBench}. This {objName} is a simple piece of jewelry, but it has a hidden twist. I will need to use common materials and follow the {processNameCont} technique to make it. I can taste the sweetness and the sourness of this piece, it surprises me.",
                                $"This {schematicType.ToLower()} tells me the way of {processNameCont} {aAn}{objName} at a {objBench}. This {objName} is a elegant piece of jewelry, it is perfect for celebrations and parties. I will need to use shiny materials and follow the {processNameCont} method to make it. I can hear the laughter and the joy of this piece, it makes me festive.",
                                $"This {schematicType.ToLower()} shows me how to get started on {processNameCont} {aAn}{objName} using a {objBench}. This {objName} is a colorful piece of jewelry, it is good for any occasion. I will need to use bright materials and follow the {processNameCont} method to make it. I can see the sparkle and the flair of this piece, it makes me dazzled.",
                                $"I will need this {schematicType.ToLower()} and access to a {objBench} to {processNameCont} {aAn}{objName}. This {objName} is a mysterious piece of jewelry, it has a secret ingredient and a hidden effect. I will need to use unknown materials and follow the {processNameCont} technique to make it. I can taste the mystery and the magic of this piece, it makes me curious.",
                                $"This {schematicType.ToLower()} explains the steps of {processNameCont} {aAn}{objName} at a {objBench}. This {objName} is a beautiful piece of jewelry, it is made with love and care. I will need to use quality materials and follow the {processNameCont} method to make it. I can feel the friendship and the generosity of this piece, it makes me grateful.",
                            };

                        switch (objType)
                        {
                            case ("Armor"):
                                flavourText = flavourText.Concat(ArmorflavourText).ToList();
                                break;
                            case ("Weapon"):
                                flavourText = flavourText.Concat(WeaponflavourText).ToList();
                                break;
                            case ("Shield"):
                                flavourText = flavourText.Concat(ShieldflavourText).ToList();
                                break;
                            case ("Cooking"):
                                flavourText = flavourText.Concat(CookingflavourText).ToList();
                                break;
                            case ("Jewelry"):
                                flavourText = flavourText.Concat(JewelryflavourText).ToList();
                                break;
                        }

                        string frontPage =
                            $"<p align='center'>\n\n\n{objName} {schematicType}\n\n\n\n</p>\n[pagebreak]";

                        string otherConditions = String.Empty;

                        if (cobj.Conditions.Count > 0)
                        {
                            otherConditions =
                                $"I understand most of this {schematicType.ToLower()}, but I think I am missing some key knowledge before being able to work with this.";

                            if (
                                (cobj.Conditions[0].Data is HasPerkConditionData cobjPerkCond)
                                && (
                                    state.LinkCache.TryResolve<IPerkGetter>(
                                        cobjPerkCond.Perk.EnumerateFormLinks().ToList()[0].FormKey,
                                        out var cobjPerk
                                    )
                                )
                            )
                            {
                                otherConditions =
                                    $"I understand most of this {schematicType.ToLower()}, but I think I am missing some key knowledge on {cobjPerk.Name} before being able to work with this.";
                            }
                        }

                        book.BookText =
                            $"{frontPage}\n<p align='left'>\nMaterials needed:\n<b>{requiredItems}</b>\n<font face='$HandwrittenFont'>{flavourText[random.Next(flavourText.Count)]} {otherConditions}</font></p>";
                        ;

                        // Add book to dict
                        itemBOOK.Add(createdItem.FormKey, book.FormKey);

                        if (settings.ShowDebugLogs)
                        {
                            Console.WriteLine($"Created {book.Name}:");
                            Console.WriteLine("-----------------------");
                            Console.WriteLine(book.BookText);
                            Console.WriteLine("-----------------------");
                            Console.WriteLine(String.Empty);
                        }

                        // Add player made schematic

                        // create a new book
                        bookPlayer = state.PatchMod.Books.AddNew();

                        // Set the book properties
                        bookPlayer.EditorID = $"{book.EditorID}_Player";
                        bookPlayer.Name = book.Name;
                        bookPlayer.Description =
                            $"A {schematicType.ToLower()} created by me. It details the process of {processNameCont} {aAn}{objName}.";
                        ;
                        bookPlayer.Value = book.Value;
                        bookPlayer.Weight = book.Weight;
                        bookPlayer.Model = book.Model;
                        bookPlayer.InventoryArt = book.InventoryArt;
                        bookPlayer.ObjectBounds = book.ObjectBounds;
                        bookPlayer.Type = book.Type;
                        bookPlayer.PickUpSound = book.PickUpSound;
                        bookPlayer.Keywords = book.Keywords;

                        // Formatting book contents
                        List<string> flavourTextPlayer =
                            new()
                            {
                                $"I spent quite some time on this {schematicType.ToLower()}. The writing is rough, the steps somewhat confusing, but it's easy enough to follow it and {processName} {aAn}{objName} at a {objBench}.",
                                $"I wrote this {schematicType.ToLower()} with great detail. It details the steps of {processNameCont} {aAn}{objName} at a {objBench}.",
                                $"Coming up with this {schematicType.ToLower()} took a lot of practice, you can see it from the scribbles and notes. They describe the steps of {processNameCont} {aAn}{objName} at a {objBench}.",
                            };

                        bookPlayer.BookText =
                            $"{frontPage}\n<p align='left'>\nMaterials needed:\n<b>{requiredItems}</b>\n<font face='$HandwrittenFont'>{flavourTextPlayer[random.Next(flavourTextPlayer.Count)]} {otherConditions}</font></p>";
                        ;

                        // Add book to dict
                        itemBOOKPlayer.Add(createdItem.FormKey, bookPlayer.FormKey);

                        // create a new book fragment
                        bookFragment = state.PatchMod.Books.AddNew();
                        string counter = $"about {noteToSchematicRatio} times";

                        // Set the fragment properties
                        bookFragment.EditorID = $"{book.EditorID}_Fragment";
                        bookFragment.Name = $"{schematicType} notes on {objName}";
                        bookFragment.Description =
                            $"Notes made on the {processNameCont} of {aAn}{objName}.";
                        bookFragment.Value = (uint)(
                            Math.Max(Math.Round(objValue / ((double)noteToSchematicRatio * 1.2)), 1)
                        );
                        bookFragment.Weight = 0.1f;
                        bookFragment.Model = bookFragmentModelLib[bookFragmentModelSetKey];
                        bookFragment.InventoryArt = new FormLinkNullable<IStaticGetter>(
                            bookFragmentStatic
                        );
                        bookFragment.ObjectBounds = bookFragmentStatic.ObjectBounds.DeepCopy();
                        bookFragment.PickUpSound = new FormLinkNullable<ISoundDescriptorGetter>(
                            Skyrim.SoundDescriptor.ITMNoteUp.FormKey
                        );
                        bookFragment.BookText =
                            $"After studying {aAn}{objName} I feel like I've grown closer to understanding how to {processName} it. I will need to repeat this process {counter} if I want to be able to {processName} {aAn}{objName} of my own.";
                        ;
                        bookFragment.Type = Book.BookType.BookOrTome;
                        bookFragment.Keywords = book.Keywords;

                        // Add book fragment to dict
                        itemBOOKFragment.Add(createdItem.FormKey, bookFragment.FormKey);

                        // Create COBJ item -> fragment
                        var itemToFragmentCOBJ = state.PatchMod.ConstructibleObjects.AddNew();

                        itemToFragmentCOBJ.EditorID = $"{objEditorID}_Breakdown_Recipe";
                        itemToFragmentCOBJ.CreatedObject =
                            new FormLinkNullable<IConstructibleGetter>(bookFragment.FormKey);

                        itemToFragmentCOBJ.Items = new Noggog.ExtendedList<ContainerEntry>();
                        itemToFragmentCOBJ.Items.Add(
                            new ContainerEntry()
                            {
                                Item = new ContainerItem()
                                {
                                    Item = new FormLink<IItemGetter>(createdItem.FormKey),
                                    Count = 1
                                },
                            }
                        );

                        itemToFragmentCOBJ.WorkbenchKeyword = new FormLinkNullable<IKeywordGetter>(
                            cobj.WorkbenchKeyword.FormKey
                        );

                        if (settings.useSmelter)
                        {
                            itemToFragmentCOBJ.WorkbenchKeyword =
                                new FormLinkNullable<IKeywordGetter>(
                                    Skyrim.Keyword.CraftingSmelter.FormKey
                                );
                        }

                        itemToFragmentCOBJ.CreatedObjectCount = (ushort?)
                            itemToFragmentCOBJ.Items.Count;

                        // Add conditions (so it doesn't clutter the menu)
                        var itemToFragmentCOBJCond = new GetItemCountConditionData()
                        {
                            RunOnType = Condition.RunOnType.Reference,
                            Reference = Skyrim.PlayerRef,
                        };
                        ;
                        itemToFragmentCOBJCond.ItemOrList = new FormLinkOrIndex<IItemOrListGetter>(
                            itemToFragmentCOBJCond,
                            createdItem.FormKey
                        );
                        itemToFragmentCOBJCond.ItemOrList.Link.SetTo(createdItemFormKey);

                        itemToFragmentCOBJ.Conditions.Add(
                            new ConditionFloat()
                            {
                                ComparisonValue = 1,
                                CompareOperator = CompareOperator.GreaterThanOrEqualTo,
                                Data = itemToFragmentCOBJCond,
                            }
                        );

                        // Create COBJ fragment -> book
                        var bookCOBJ = state.PatchMod.ConstructibleObjects.AddNew();

                        bookCOBJ.EditorID = $"{objEditorID}_{schematicType}_Recipe";
                        bookCOBJ.CreatedObject = new FormLinkNullable<IConstructibleGetter>(
                            bookPlayer.FormKey
                        );

                        bookCOBJ.Items = new Noggog.ExtendedList<ContainerEntry>();
                        bookCOBJ.Items.Add(
                            new ContainerEntry()
                            {
                                Item = new ContainerItem()
                                {
                                    Item = new FormLink<IItemGetter>(bookFragment.FormKey),
                                    Count = (int)noteToSchematicRatio
                                },
                            }
                        );
                        bookCOBJ.WorkbenchKeyword = new FormLinkNullable<IKeywordGetter>(
                            cobj.WorkbenchKeyword.FormKey
                        );
                        bookCOBJ.CreatedObjectCount = (ushort?)bookCOBJ.Items.Count;

                        // Add conditions (so it doesn't clutter the menu)
                        var bookCOBJCond = new GetItemCountConditionData()
                        {
                            RunOnType = Condition.RunOnType.Reference,
                            Reference = Skyrim.PlayerRef,
                        };
                        ;
                        bookCOBJCond.ItemOrList = new FormLinkOrIndex<IItemOrListGetter>(
                            bookCOBJCond,
                            bookFragment.FormKey
                        );
                        bookCOBJCond.ItemOrList.Link.SetTo(bookFragment);

                        var bookCOBJCondItem = new ConditionFloat()
                        {
                            ComparisonValue = noteToSchematicRatio,
                            CompareOperator = CompareOperator.GreaterThanOrEqualTo,
                            Data = bookCOBJCond
                        };

                        bookCOBJ.Conditions.Add(bookCOBJCondItem);

                        if (settings.ShowDebugLogs)
                        {
                            Console.WriteLine($"Created {bookFragment.Name}:");
                            Console.WriteLine("-----------------------");
                            Console.WriteLine(bookFragment.BookText);
                            Console.WriteLine("-----------------------");
                            Console.WriteLine(String.Empty);
                        }
                    }
                    else
                    {
                        // Link to existing book
                        if (
                            !state.LinkCache.TryResolve<IBookGetter>(
                                itemBOOK[createdItemFormKey],
                                out var bookLink
                            )
                            || !state.LinkCache.TryResolve<IBookGetter>(
                                itemBOOKPlayer[createdItemFormKey],
                                out var bookPlayerLink
                            )
                        )
                            continue;

                        if (
                            (bookLink is not Book BookLinkBook)
                            || (bookPlayerLink is not Book BookPlayerLinkBook)
                        )
                            continue;

                        book = BookLinkBook;
                        bookPlayer = BookPlayerLinkBook;
                    }

                    // Create a new COBJ record with the modified conditions
                    var modifiedCOBJ = state.PatchMod.ConstructibleObjects.GetOrAddAsOverride(cobj);

                    // Blacksmith tutorial workaround

                    if (
                        cobj.FormKey == Skyrim.ConstructibleObject.RecipeWeaponIronDagger.FormKey
                        || cobj.FormKey == Skyrim.ConstructibleObject.RecipeLeatherDeerHide.FormKey
                        || cobj.FormKey == Skyrim.ConstructibleObject.RecipeArmorHideHelmet.FormKey
                    )
                    {
                        var SmithTutorialCond = new GetStageConditionData();
                        SmithTutorialCond.Quest = new FormLinkOrIndex<IQuestGetter>(
                            SmithTutorialCond,
                            Skyrim.Quest.TutorialBlacksmithing.FormKey
                        );
                        SmithTutorialCond.Quest.Link.SetTo(
                            Skyrim.Quest.TutorialBlacksmithing.FormKey
                        );
                        var conditionBase = new ConditionFloat()
                        {
                            ComparisonValue = 10,
                            CompareOperator = CompareOperator.GreaterThanOrEqualTo,
                            Data = SmithTutorialCond,
                            Flags = Condition.Flag.OR
                        };

                        if (
                            cobj.FormKey
                            == Skyrim.ConstructibleObject.RecipeWeaponIronDagger.FormKey
                        )
                        {
                            conditionBase.ComparisonValue = 10;
                        }
                        else if (
                            cobj.FormKey == Skyrim.ConstructibleObject.RecipeLeatherDeerHide.FormKey
                        )
                        {
                            conditionBase.ComparisonValue = 50;
                        }
                        else if (
                            cobj.FormKey == Skyrim.ConstructibleObject.RecipeArmorHideHelmet.FormKey
                        )
                        {
                            conditionBase.ComparisonValue = 70;
                        }

                        modifiedCOBJ.Conditions.Add(conditionBase);
                    }

                    // Add book conditions
                    var bookCond = new GetItemCountConditionData()
                    {
                        RunOnType = Condition.RunOnType.Reference,
                        Reference = Skyrim.PlayerRef,
                    };
                    bookCond.ItemOrList = new FormLinkOrIndex<IItemOrListGetter>(
                        bookCond,
                        book.FormKey
                    );
                    bookCond.ItemOrList.Link.SetTo(book);

                    var bookCondPlayer = new GetItemCountConditionData()
                    {
                        RunOnType = Condition.RunOnType.Reference,
                        Reference = Skyrim.PlayerRef,
                    };
                    bookCondPlayer.ItemOrList = new FormLinkOrIndex<IItemOrListGetter>(
                        bookCondPlayer,
                        bookPlayer.FormKey
                    );
                    bookCondPlayer.ItemOrList.Link.SetTo(bookPlayer);

                    modifiedCOBJ.Conditions.Add(
                        new ConditionFloat()
                        {
                            ComparisonValue = 1,
                            CompareOperator = CompareOperator.GreaterThanOrEqualTo,
                            Data = bookCond,
                            Flags = Condition.Flag.OR
                        }
                    );

                    modifiedCOBJ.Conditions.Add(
                        new ConditionFloat()
                        {
                            ComparisonValue = 1,
                            CompareOperator = CompareOperator.GreaterThanOrEqualTo,
                            Data = bookCondPlayer,
                        }
                    );

                    if (settings.ShowDebugLogs)
                        Console.WriteLine($"    Patched {cobj.EditorID} with {book.EditorID}");
                }

                // Make tempered COBJs also require schematics
                if (settings.TemperReqSchematic)
                {
                    foreach (
                        IConstructibleObjectGetter temperCOBJ in state.LoadOrder.PriorityOrder
                            .ConstructibleObject()
                            .WinningOverrides()
                    )
                    {
                        // Define LVLI and check if it's empty
                        if (
                            temperCOBJ.CreatedObject.FormKey != createdItemFormKey
                            || (
                                temperCOBJ.WorkbenchKeyword.FormKey
                                    != Skyrim.Keyword.CraftingSmithingArmorTable.FormKey
                                && temperCOBJ.WorkbenchKeyword.FormKey
                                    != Skyrim.Keyword.CraftingSmithingSharpeningWheel.FormKey
                            )
                        )
                            continue;

                        if (settings.ShowDebugLogs)
                        {
                            Console.WriteLine(String.Empty);
                            Console.WriteLine(
                                $"Patching tempering COBJs to require new schematics ..."
                            );
                        }

                        // Set up condition
                        var bookCond = new GetItemCountConditionData()
                        {
                            RunOnType = Condition.RunOnType.Reference,
                            Reference = Skyrim.PlayerRef,
                        };
                        bookCond.ItemOrList = new FormLinkOrIndex<IItemOrListGetter>(
                            bookCond,
                            itemBOOK[createdItemFormKey]
                        );
                        bookCond.ItemOrList.Link.SetTo(itemBOOK[createdItemFormKey]);

                        // add condition
                        var modifiedTemperCOBJ =
                            state.PatchMod.ConstructibleObjects.GetOrAddAsOverride(temperCOBJ);

                        // Blacksmith tutorial workaround

                        if (
                            temperCOBJ.FormKey
                                == Skyrim.ConstructibleObject.TemperWeaponIronDagger.FormKey
                            || temperCOBJ.FormKey
                                == Skyrim.ConstructibleObject.TemperArmorHideHelmet.FormKey
                        )
                        {
                            var SmithTutorialCond = new GetStageConditionData();
                            SmithTutorialCond.Quest = new FormLinkOrIndex<IQuestGetter>(
                                SmithTutorialCond,
                                Skyrim.Quest.TutorialBlacksmithing.FormKey
                            );
                            SmithTutorialCond.Quest.Link.SetTo(
                                Skyrim.Quest.TutorialBlacksmithing.FormKey
                            );
                            var conditionBase = new ConditionFloat()
                            {
                                ComparisonValue = 30,
                                CompareOperator = CompareOperator.GreaterThanOrEqualTo,
                                Data = SmithTutorialCond,
                                Flags = Condition.Flag.OR
                            };

                            if (
                                temperCOBJ.FormKey
                                == Skyrim.ConstructibleObject.TemperArmorHideHelmet.FormKey
                            )
                            {
                                conditionBase.ComparisonValue = 90;
                            }

                            modifiedTemperCOBJ.Conditions.Add(conditionBase);
                        }

                        modifiedTemperCOBJ.Conditions.Add(
                            new ConditionFloat()
                            {
                                ComparisonValue = 1,
                                CompareOperator = CompareOperator.GreaterThanOrEqualTo,
                                Data = bookCond,
                                Flags = Condition.Flag.OR
                            }
                        );

                        // Add player book as cond
                        var bookCondPlayer = new GetItemCountConditionData()
                        {
                            RunOnType = Condition.RunOnType.Reference,
                            Reference = Skyrim.PlayerRef,
                        };
                        bookCondPlayer.ItemOrList = new FormLinkOrIndex<IItemOrListGetter>(
                            bookCondPlayer,
                            itemBOOKPlayer[createdItemFormKey]
                        );
                        bookCondPlayer.ItemOrList.Link.SetTo(itemBOOKPlayer[createdItemFormKey]);

                        modifiedTemperCOBJ.Conditions.Add(
                            new ConditionFloat()
                            {
                                ComparisonValue = 1,
                                CompareOperator = CompareOperator.GreaterThanOrEqualTo,
                                Data = bookCondPlayer,
                            }
                        );
                    }
                }

                if (settings.ShowDebugLogs)
                {
                    Console.WriteLine(String.Empty);
                    Console.WriteLine($"Patching LVLIs to include new schematics ...");
                }

                foreach (FormKey lvliFormKey in itemLVLIs[createdItemFormKey])
                {
                    // Define LVLI and check if it's empty
                    if (
                        !state.LinkCache.TryResolve<ILeveledItemGetter>(
                            lvliFormKey,
                            out var leveledList
                        )
                        && leveledList?.Entries == null
                    )
                        continue;

                    // Define the LVLI to be made specifically for the schematic
                    LeveledItem schematicLVLI;

                    // basic book entry to be added to schematicLVLI
                    LeveledItemEntry bookEntry = new LeveledItemEntry()
                    {
                        Data = new LeveledItemEntryData()
                        {
                            Reference = new FormLink<IItemGetter>(itemBOOK[createdItemFormKey]),
                            Level = 1,
                            Count = 1
                        }
                    };

                    string leveledItemIDTemplate = $"{objEditorID}_Schematic_Entry";

                    if (!bookLVLIs.ContainsKey(itemBOOK[createdItemFormKey]))
                        bookLVLIs.Add(
                            itemBOOK[createdItemFormKey],
                            new Dictionary<String, FormKey>()
                        );

                    if (!bookLVLIs[itemBOOK[createdItemFormKey]].ContainsKey(leveledItemIDTemplate))
                    {
                        // Create leveled list for each item with a user customizable drop chance
                        schematicLVLI = state.PatchMod.LeveledItems.AddNew();
                        schematicLVLI.ChanceNone = (byte)(100 - settings.DropChance);
                        schematicLVLI.EditorID = leveledItemIDTemplate;
                        schematicLVLI.Entries = new Noggog.ExtendedList<LeveledItemEntry>();
                        schematicLVLI.Entries.Add(bookEntry);
                        bookLVLIs[itemBOOK[createdItemFormKey]].Add(
                            schematicLVLI.EditorID,
                            schematicLVLI.FormKey
                        );
                    }
                    else
                    {
                        // Link to existing book
                        if (
                            !state.LinkCache.TryResolve<ILeveledItemGetter>(
                                bookLVLIs[itemBOOK[createdItemFormKey]][leveledItemIDTemplate],
                                out var schematicLVLILink
                            )
                        )
                            continue;

                        if (schematicLVLILink is not LeveledItem schematicLVLILinkLVLI)
                            continue;

                        schematicLVLI = schematicLVLILinkLVLI;
                    }

                    if (settings.ShowDebugLogs)
                    {
                        Console.WriteLine(String.Empty);
                        Console.WriteLine(
                            $"    Injecting {schematicLVLI.EditorID} in {leveledList.EditorID}"
                        );
                    }

                    for (int i = 0; i < leveledList.Entries?.Count; i++)
                    {
                        var existingEntry = leveledList.Entries[i];
                        if (existingEntry.Data?.Reference.FormKey != createdItem.FormKey)
                            continue;

                        // Get the level of the existing entry
                        short existingLevel = existingEntry?.Data?.Level ?? 1;

                        // Create a new entry with the new item and the same level
                        LeveledItemEntry newEntry = new LeveledItemEntry()
                        {
                            Data = new LeveledItemEntryData()
                            {
                                Reference = new FormLink<IItemGetter>(schematicLVLI),
                                Level = existingLevel,
                                Count = 1
                            }
                        };

                        LeveledItem modifiedBaseLVLI =
                            state.PatchMod.LeveledItems.GetOrAddAsOverride(leveledList);

                        // Add the new entry to the leveled list
                        if (modifiedBaseLVLI.Entries == null)
                            modifiedBaseLVLI.Entries = new Noggog.ExtendedList<LeveledItemEntry>();
                        modifiedBaseLVLI.Entries.Add(newEntry);

                        if (settings.ShowDebugLogs)
                            Console.WriteLine($"        Injected at level {existingLevel};");
                    }
                }

                // Temporary "fix" for hitting the LVLI entry cap

                var overflownFormkeys = new Dictionary<FormKey, List<FormKey>>();

                foreach (var lvliFormKey in itemLVLIs[createdItemFormKey])
                {
                    // Define LVLI and check if it's empty
                    if (
                        !state.LinkCache.TryResolve<ILeveledItemGetter>(
                            lvliFormKey,
                            out var leveledList
                        )
                    )
                        continue;

                    if (leveledList.Entries?.Count >= 254)
                    {
                        if (!overflownFormkeys.ContainsKey(createdItemFormKey))
                            overflownFormkeys.Add(createdItemFormKey, new List<FormKey>());
                        overflownFormkeys[createdItemFormKey].Add(leveledList.FormKey);
                    }
                }

                if (!overflownFormkeys.ContainsKey(createdItemFormKey))
                    continue;

                Console.WriteLine(String.Empty);
                Console.WriteLine($"oopsie doopsie uwu too many items in this leveled list");

                if (
                    overflownFormkeys[createdItemFormKey].Count
                    == itemLVLIs[createdItemFormKey].Count
                )
                {
                    // Define LVLI and check if it's empty
                    if (
                        !state.LinkCache.TryResolve<ILeveledItemGetter>(
                            overflownFormkeys[createdItemFormKey][0],
                            out var leveledList
                        )
                    )
                        continue;

                    foreach (var lvliFormKey in bookLVLIs[itemBOOK[createdItemFormKey]])
                    {
                        // Define LVLI and check if it's empty
                        if (
                            !state.LinkCache.TryResolve<ILeveledItemGetter>(
                                lvliFormKey.Value,
                                out var lvli
                            )
                        )
                            continue;
                        state.PatchMod.LeveledItems.Remove(lvli);
                    }

                    state.PatchMod.Books.Remove(itemBOOK[createdItem.FormKey]);
                    state.PatchMod.Books.Remove(itemBOOKFragment[createdItem.FormKey]);

                    // Delete cobj condition changes, book and book fragment cobjs
                    foreach (var cobj in state.PatchMod.ConstructibleObjects)
                    {
                        if (
                            itemCOBJs[createdItemFormKey].Any(e => e == cobj.FormKey)
                            || cobj.CreatedObject.FormKey == itemBOOK[createdItem.FormKey]
                            || cobj.CreatedObject.FormKey == itemBOOKFragment[createdItem.FormKey]
                        )
                        {
                            state.PatchMod.ConstructibleObjects.Remove(cobj);
                        }
                    }

                    // delete schematic
                    state.PatchMod.LeveledItems.Remove(leveledList);
                    Console.WriteLine($"undoing all the modifications made from this item");
                }
                else
                {
                    foreach (var lvliFormKey in overflownFormkeys[createdItemFormKey])
                    {
                        state.PatchMod.LeveledItems.Remove(lvliFormKey);
                        Console.WriteLine(
                            $"undoing just the funky wunky lvli and keeping the rest"
                        );
                    }
                }
            }

            Console.WriteLine(String.Empty);
            Console.WriteLine("=================================================");
        }
    }
}
