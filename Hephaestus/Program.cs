// Hephaestus.cs
// A mutagen synthesis patcher that randomizes the height of all human COBJs in a deterministic manner
// The patcher can be configured with a minimum and maximum value for each race and gender of that race

using Mutagen.Bethesda;
using Mutagen.Bethesda.FormKeys.SkyrimSE;
using Mutagen.Bethesda.Plugins;
using Mutagen.Bethesda.Plugins.Aspects;
using Mutagen.Bethesda.Skyrim;
using Mutagen.Bethesda.Synthesis;

namespace Hephaestus
{
    public class Program
    {
        static Lazy<Settings> _settings = null!;
        public static Settings settings => _settings.Value;

        public static async Task<int> Main(string[] args)
        {
            // Run the patcher
            return await SynthesisPipeline.Instance
                .AddPatch<ISkyrimMod, ISkyrimModGetter>(RunPatch)
                .SetTypicalOpen(GameRelease.SkyrimSE, "Hephaestus.esp")
                .SetAutogeneratedSettings("Settings", "settings.json", out _settings)
                .Run(args);
        }

        // A method to run the patch on a given load order
        private static void RunPatch(IPatcherState<ISkyrimMod, ISkyrimModGetter> state)
        {
            char[] vowels = { 'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U' };

            // Building the flavour text
            string[] flavourText =
            {
                $"looks like the notes of a madman, though I can somewhat decypher it. It seems to detail the process of",
                $"seems to have been teared off from someone's journal. It seems to explain the process of",
                $"seems to have been written by an apprentice, from the looks of it it describes the process of",
                $"goes into great detail on the steps of",
                $"contains the secrets to",
                $"is filled with scribbles and notes on the steps of",
                $"still has some stains of blood on it, it describes the process of"
            };

            Console.WriteLine("");
            Console.WriteLine("=================================================");
            Console.WriteLine("Starting COBJ Patching...");
            Console.WriteLine("=================================================");
            Console.WriteLine("");

            // **Main Mechanic**
            // 7. We patch the blacksmithing intro quest to give you the relevant schematics with the materials.

            // Loop through all the COBJ records in the load order
            foreach (
                IConstructibleObjectGetter cobj in state.LoadOrder.PriorityOrder
                    .ConstructibleObject()
                    .WinningOverrides()
            )
            {
                if (!cobj.CreatedObject.TryResolve(state.LinkCache, out var createdItem))
                    continue;
                if (
                    createdItem is not INamedGetter namedObj
                    || createdItem is not IWeightValueGetter weightValue
                )
                    continue;
                if (cobj.Items is null)
                    continue;

                List<FormKey> leveledLists = new List<FormKey>();

                // Look up LVLI with item
                foreach (
                    var leveledList in state.LoadOrder.PriorityOrder
                        .LeveledItem()
                        .WinningOverrides()
                )
                {
                    // Check if the leveled list contains the item and if it's already been added
                    if (
                        leveledList.Entries != null
                        && leveledList.Entries.Any(
                            e => e.Data?.Reference.FormKey == createdItem.FormKey
                        )
                        && !leveledLists.Any(e => e == leveledList.FormKey)
                    )
                    {
                        leveledLists.Add(leveledList.FormKey);
                    }
                    else
                        continue;
                }

                // Deterministic seed
                var random = new Random(cobj.FormKey.ID.GetHashCode());

                // Base Scroll
                var schematicBase = Skyrim.Scroll.EbonyFleshScroll.TryResolve(state.LinkCache);
                var objModel = schematicBase?.Model?.DeepCopy() ?? new Model();
                var objInvArt = schematicBase?.MenuDisplayObject.TryResolve(state.LinkCache);
                var objBounds = schematicBase?.ObjectBounds?.DeepCopy() ?? new ObjectBounds();

                // Base Object
                string? objName = namedObj.Name;
                string? objType = string.Empty;
                string? objEditorID = createdItem.EditorID;
                uint objValue = weightValue.Value;

                // Book variables
                Book book;
                string? objBench;
                string? processName;
                string schematicType = "Schematic";
                string? requiredItems = string.Empty;
                string aAn = "a";
                if (objName?.IndexOfAny(vowels) == 0)
                    aAn = "an";

                // Set values based on bench
                if (cobj.WorkbenchKeyword.FormKey == Skyrim.Keyword.CraftingSmithingForge.FormKey)
                {
                    objBench = "Forge";
                    processName = "forging";

                    _ = createdItem switch
                    {
                        IWeaponGetter => objType = "Weapon",
                        IArmorGetter => objType = "Armor",
                        _ => objType = "Misc"
                    };

                    if (createdItem is IArmorGetter armorObj)
                    {
                        var flagToCheck = armorObj.BodyTemplate;
                        if (flagToCheck == null)
                            continue;
                        else if (
                            flagToCheck.FirstPersonFlags.HasFlag(BipedObjectFlag.Hands)
                            || flagToCheck.FirstPersonFlags.HasFlag(BipedObjectFlag.Feet)
                        )
                        {
                            aAn = "a pair of";
                        }
                        else if (
                            flagToCheck.FirstPersonFlags.HasFlag(BipedObjectFlag.Amulet)
                            || flagToCheck.FirstPersonFlags.HasFlag(BipedObjectFlag.Ring)
                        )
                        {
                            objType = "Jewelry";
                        }

                        if (armorObj.EquipmentType.FormKey == Skyrim.EquipType.Shield.FormKey)
                        {
                            objType = "Shield";
                        }
                    }
                }
                else if (
                    cobj.WorkbenchKeyword.FormKey == Skyrim.Keyword.CraftingTanningRack.FormKey
                )
                {
                    objBench = "Tanning Rack";
                    processName = "tanning";
                    objType = "Misc";
                }
                else if (cobj.WorkbenchKeyword.FormKey == Skyrim.Keyword.CraftingCookpot.FormKey)
                {
                    objBench = "cooking pot";
                    schematicType = "Recipe";
                    processName = "cooking";

                    _ = createdItem switch
                    {
                        IIngredientGetter => objType = "Ingredient",
                        _ => objType = "Food"
                    };
                }
                else
                    continue;

                foreach (var reqItem in cobj.Items)
                {
                    if (!reqItem.Item.Item.TryResolve(state.LinkCache, out var reqItemObj))
                        continue;
                    if (reqItemObj is not INamedGetter namedItem)
                        continue;
                    requiredItems += $"{namedItem?.Name}\n";
                }
                ;

                // Assigning flavour data
                string bookTextTemplate =
                    $"{objName} {schematicType}\n\nMaterials needed:\n{requiredItems}\n<img src='img://Textures/Interface/Books/Illuminated_Letters/T_letter.png'>his {schematicType.ToLower()} {flavourText[random.Next(flavourText.Length)]} {processName} {aAn} {objName} at a {objBench}. I better not lose this.";
                string bookEditorIDTemplate = $"{objEditorID}_{schematicType}";

                // Check if a schematic with the same editor ID already exists
                if (state.PatchMod.Books.Any(l => l.EditorID == bookEditorIDTemplate))
                {
                    book = state.PatchMod.Books.First(e => e.EditorID == bookEditorIDTemplate);
                }
                else
                {
                    // create a new book
                    book = state.PatchMod.Books.AddNew(objEditorID);

                    // Set the book properties
                    book.EditorID = bookEditorIDTemplate;
                    book.Name = $"{objType} {schematicType}: {objName}";
                    book.Value = objValue * 5;
                    book.Weight = 0.1f;
                    book.Model = objModel;
                    // book.InventoryArt = objInvArt;
                    book.ObjectBounds = objBounds;
                    book.BookText = bookTextTemplate;
                    book.Type = Book.BookType.NoteOrScroll;

                    if (settings.ShowDebugLogs)
                    {
                        Console.WriteLine(book.Name);
                        Console.WriteLine(book.BookText);
                        Console.WriteLine("");
                        Console.WriteLine("=================================================");
                        Console.WriteLine("");
                    }
                }
                ;

                // Create a new COBJ record with the modified height and add it to the output mod
                var modifiedCobj = state.PatchMod.ConstructibleObjects.GetOrAddAsOverride(cobj);
                GetItemCountConditionData newCond = new GetItemCountConditionData();
                newCond.ItemOrList = new FormLinkOrIndex<IItemOrListGetter>(newCond, book.FormKey);
                newCond.ItemOrList.Link.SetTo(book);

                modifiedCobj.Conditions.Add(
                    new ConditionFloat()
                    {
                        ComparisonValue = 1,
                        CompareOperator = CompareOperator.GreaterThanOrEqualTo,
                        Data = newCond
                    }
                );

                // Add schematic to LVLI
                foreach (FormKey leveledListKey in leveledLists)
                {
                    var leveledList = state.LoadOrder.PriorityOrder
                        .LeveledItem()
                        .WinningOverrides()
                        .First(e => e.FormKey == leveledListKey);

                    // Define the LVLI to be made specifically for the schematic
                    LeveledItem schematicLVLI;

                    Console.WriteLine(leveledList.EditorID);

                    LeveledItemEntry bookEntry = new LeveledItemEntry()
                    {
                        Data = new LeveledItemEntryData()
                        {
                            Reference = new FormLink<IItemGetter>(book.FormKey),
                            Level = 1,
                            Count = 1
                        }
                    };

                    if (leveledList.Entries == null)
                        continue;

                    for (int i = 0; i < leveledList.Entries?.Count; i++)
                    {
                        var existingEntry = leveledList.Entries[i];
                        if (existingEntry.Data?.Reference.FormKey != createdItem.FormKey)
                            continue;

                        // Get the level of the existing entry
                        short existingLevel =
                            leveledList.Entries
                                ?.First(e => e.Data?.Reference.FormKey == createdItem.FormKey)
                                ?.Data?.Level ?? 1;

                        // Check if a leveled list with the same editor ID already exists
                        if (
                            state.PatchMod.LeveledItems.Any(
                                l =>
                                    l.EditorID == $"{objEditorID}_{schematicType}_Lv{existingLevel}"
                            )
                        )
                        {
                            schematicLVLI = state.PatchMod.LeveledItems.First(
                                e =>
                                    e.EditorID == $"{objEditorID}_{schematicType}_Lv{existingLevel}"
                            );
                        }
                        else
                        {
                            // Create leveled list for each item with a user customizable drop chance
                            schematicLVLI = state.PatchMod.LeveledItems.AddNew();
                            schematicLVLI.ChanceNone = (byte)(100 - settings.DropChance);
                            schematicLVLI.EditorID =
                                $"{objEditorID}_{schematicType}_Lv{existingLevel}";
                            schematicLVLI.Entries = new Noggog.ExtendedList<LeveledItemEntry>();
                            schematicLVLI.Entries.Add(bookEntry);
                        }
                        ;

                        // Create a new entry with the new item and the same level
                        LeveledItemEntry newEntry = new LeveledItemEntry()
                        {
                            Data = new LeveledItemEntryData()
                            {
                                Reference = new FormLink<IItemGetter>(schematicLVLI),
                                Level = existingLevel,
                                Count = 1
                            }
                        };

                        LeveledItem modifiedBaseLVLI =
                            state.PatchMod.LeveledItems.GetOrAddAsOverride(leveledList);

                        // Add the new entry to the leveled list
                        if (modifiedBaseLVLI.Entries == null)
                            modifiedBaseLVLI.Entries = new Noggog.ExtendedList<LeveledItemEntry>();
                        modifiedBaseLVLI.Entries.Add(newEntry);
                    }
                }
            }

            Console.WriteLine("");
            Console.WriteLine("=================================================");
        }
    }
}
