using Mutagen.Bethesda;
using Mutagen.Bethesda.FormKeys.SkyrimSE;
using Mutagen.Bethesda.Plugins;
using Mutagen.Bethesda.Plugins.Aspects;
using Mutagen.Bethesda.Plugins.Records;
using Mutagen.Bethesda.Skyrim;
using Mutagen.Bethesda.Synthesis;
using Noggog;

namespace Hephaestus
{
    // To do
    // refactor code, too much duplicated initializations of books, book fragments, conds, etc.
    // Dialogue options to blacksmiths to tell you about each item type and what it can craft? Even better, have two powers, one for breaking down (Research) and another for drawing up schematics (putting them together; Drawing)

    public class Program
    {
        static Lazy<Settings> _settings = null!;
        public static Settings Settings => _settings.Value;

        public static async Task<int> Main(string[] args)
        {
            // Run the patcher
            return await SynthesisPipeline
                .Instance.AddPatch<ISkyrimMod, ISkyrimModGetter>(RunPatch)
                .SetTypicalOpen(GameRelease.SkyrimSE, "Hephaestus.esp")
                .SetAutogeneratedSettings("Settings", "settings.json", out _settings)
                .Run(args);
        }

        private static void RunPatch(IPatcherState<ISkyrimMod, ISkyrimModGetter> state)
        {
            Dictionary<string, PartData> partListUniques = new();
            Dictionary<string, Dictionary<string, FormKey>> partDict = new();
            Dictionary<FormKey, List<FormKey>> bookKnowledge = new();
            Dictionary<FormKey, List<FormKey>> itemCOBJs = new();
            Dictionary<FormKey, List<FormKey>> itemKnowledgeReq = new();
            Dictionary<FormKey, List<string>> itemMaterials = new();
            Dictionary<FormKey, FormKey> itemBench = new();
            Dictionary<FormKey, Dictionary<string, FormKey>> benchKeywordSwap = new();
            List<FormKey> noValidMats = new();
            List<FormKey> safeToKeepKnowledge = new();
            Dictionary<FormKey, FormKey> itemLVLIEntries = new();

            Console.WriteLine(string.Empty);
            Console.WriteLine("=================================================");
            Console.WriteLine(string.Empty);
            Console.WriteLine("Prep phase ...");
            Console.WriteLine(string.Empty);

            // LVLI Whitelist base
            List<FormKey> LootLVLIWhitelist = new();
            LootLVLIWhitelist.AddRange(GenData.LootLVLIWhitelistBase);
            if (Settings.DistributeVendors)
                LootLVLIWhitelist.AddRange(GenData.LootLVLIWhitelistVendor);
            if (Settings.DistributeBlacksmiths)
                LootLVLIWhitelist.AddRange(GenData.LootLVLIWhitelistBlacksmith);
            if (Settings.DistributeSpecial)
                LootLVLIWhitelist.AddRange(GenData.LootLVLIWhitelistSpecial);

            // Copy the script (if necessary)
            string sourcePath = state.RetrieveInternalFile("_camp_craftingobjecteffectscript.pex");
            string destPath = Path.Combine(
                state.DataFolderPath,
                "Scripts",
                "_camp_craftingobjecteffectscript.pex"
            );
            if (!File.Exists(destPath))
                File.Copy(sourcePath, destPath, true);

            // Message that appears when trying to dismantle/process while mounted
            Message mountedMessage =
                new(state.PatchMod)
                {
                    EditorID = "HephaestusMountedMessage",
                    Description = "You cannot research while mounted.",
                    DisplayTime = 2,
                };
            state.PatchMod.Messages.Set(mountedMessage);

            // Quest to give the player spells at the beginning of the game
            Quest hephaestusStartGameGiver =
                new(state.PatchMod)
                {
                    EditorID = "Hephaestus_StartGameDistributor",
                    Flags = Quest.Flag.StartGameEnabled,
                    Stages = new()
                    {
                        new() { Index = 0, Flags = QuestStage.Flag.StartUpStage }
                    },
                    Aliases = new()
                    {
                        new() { ForcedReference = Skyrim.PlayerRef.AsNullable(), Spells = new() }
                    }
                };
            state.PatchMod.Quests.Set(hephaestusStartGameGiver);

            // Used as a dumping ground to call the furniture from when using the spells
            var overrideCell = state
                .LinkCache.ResolveContext<ICell, ICellGetter>(Skyrim.Cell.QASmoke.FormKey)
                .GetOrAddAsOverride(state.PatchMod);

            void GenerateCustomMenu(
                IFormLinkGetter<IKeywordGetter> originalKeyword,
                string benchType,
                string benchName,
                string processName,
                string schematicTypeName,
                IFormLinkNullable<IStaticGetter> menuStatic,
                bool giveSmithingExp
            )
            {
                // Create the keyword
                Keyword benchKeyword = state.PatchMod.Keywords.AddNew();
                benchKeyword.EditorID = $"Hephaestus_{benchName.Replace(" ", "")}Menu_{benchType}";

                string benchNameID = $"{benchName.Replace(" ", "")}_{benchType}";
                Furniture customMenuFurniture =
                    new(state.PatchMod)
                    {
                        Name = benchName,
                        EditorID = $"Hephaestus_{benchNameID}_Furniture",
                        Model = new() { File = "Furniture\\SitCrossLeggedMarker.nif" },
                        InteractionKeyword = new FormLinkNullable<IKeywordGetter>(
                            Skyrim.Keyword.ActorTypeNPC.FormKey
                        ),
                        Flags = Furniture.Flag.MustExitToTalk,
                        WorkbenchData = new() { BenchType = WorkbenchData.Type.CreateObject, },
                        Keywords = new() { benchKeyword }
                    };
                if (giveSmithingExp)
                    customMenuFurniture.WorkbenchData.UsesSkill = Skill.Smithing;
                state.PatchMod.Furniture.Set(customMenuFurniture);

                // place the furniture
                PlacedObject customMenuPlacedReference =
                    new(state.PatchMod)
                    {
                        EditorID = $"Hephaestus_{benchNameID}_Reference",
                        Base = customMenuFurniture.ToNullableLink(),
                        Placement = new()
                        {
                            Position = new()
                            {
                                X = 0,
                                Y = 0,
                                Z = -3000
                            },
                            Rotation = new()
                            {
                                X = 0,
                                Y = 0,
                                Z = 0
                            }
                        }
                    };
                overrideCell.Temporary.Add(customMenuPlacedReference);

                // Create the furniture effect
                MagicEffect customMenuScriptDummy =
                    new(state.PatchMod)
                    {
                        EditorID = $"Hephaestus_{benchNameID}_ScriptDummy",
                        MenuDisplayObject = Skyrim.Static.BlacksmithAnvilStatic.AsNullable(),
                        CastType = CastType.FireAndForget,
                        TargetType = TargetType.Self,
                        Flags =
                            MagicEffect.Flag.HideInUI
                            | MagicEffect.Flag.NoDuration
                            | MagicEffect.Flag.NoMagnitude
                            | MagicEffect.Flag.NoArea,
                        CastingSoundLevel = SoundLevel.Loud,
                        VirtualMachineAdapter = new()
                        {
                            Version = 5,
                            ObjectFormat = 2,
                            Scripts = new()
                            {
                                new ScriptEntry()
                                {
                                    Name = "_Camp_CraftingObjectEffectScript",
                                    Flags = ScriptEntry.Flag.Local,
                                    Properties = new()
                                    {
                                        new ScriptObjectProperty()
                                        {
                                            Name = "PlayerRef",
                                            Flags = ScriptProperty.Flag.Edited,
                                            Object = Skyrim.PlayerRef
                                        },
                                        new ScriptObjectProperty()
                                        {
                                            Name = "_Camp_CraftingObjectREF",
                                            Flags = ScriptProperty.Flag.Edited,
                                            Object = customMenuPlacedReference.ToNullableLink()
                                        },
                                        new ScriptObjectProperty()
                                        {
                                            Name = "_Camp_GeneralError_Mounted",
                                            Flags = ScriptProperty.Flag.Edited,
                                            Object = mountedMessage.ToNullableLink()
                                        }
                                    }
                                }
                            }
                        }
                    };
                state.PatchMod.MagicEffects.Set(customMenuScriptDummy);

                Spell customMenuSpell =
                    new(state.PatchMod)
                    {
                        EditorID = $"Hephaestus_{benchNameID}_Menu",
                        Name = $"Research - {benchName}",
                        Description = $"Learn how to {processName} at a {benchName}.",
                        MenuDisplayObject = menuStatic,
                        EquipmentType = Skyrim.EquipType.Voice.AsNullable(),
                        Type = SpellType.LesserPower,
                        CastType = CastType.FireAndForget,
                        TargetType = TargetType.Self,

                        Effects = new()
                        {
                            new Effect() { BaseEffect = customMenuScriptDummy.ToNullableLink(), }
                        }
                    };
                state.PatchMod.Spells.Set(customMenuSpell);

                Console.WriteLine(benchType);
                Console.WriteLine(benchKeywordSwap[originalKeyword.FormKey].Count);

                benchKeywordSwap[originalKeyword.FormKey].Add(benchType, benchKeyword.FormKey);
                hephaestusStartGameGiver.Aliases.First().Spells.Add(customMenuSpell);
            }
            ;

            void applyBookDefaults(string seed, Book book)
            {
                // Deterministic seed
                var random = new Random(seed.GetHashCode());

                // Randomize book model
                var bookModelSetKey = GenData.bookModelLib.Keys.ElementAt(
                    (int)Math.Round((GenData.bookModelLib.Count - 1) * (float)random.NextDouble())
                );
                if (!state.LinkCache.TryResolve<IStaticGetter>(bookModelSetKey, out var bookStatic))
                    return;

                // Randomize fragment model
                var bookFragmentModelSetKey = GenData.bookFragmentModelLib.Keys.ElementAt(
                    (int)
                        Math.Round(
                            (GenData.bookFragmentModelLib.Count - 1) * (float)random.NextDouble()
                        )
                );
                if (
                    !state.LinkCache.TryResolve<IStaticGetter>(
                        bookFragmentModelSetKey,
                        out var bookFragmentStatic
                    )
                )
                    return;

                book.Weight = 0.25f;
                book.Model = GenData.bookModelLib[bookModelSetKey];
                book.InventoryArt = bookStatic.ToNullableLink();
                book.ObjectBounds = bookStatic.ObjectBounds.DeepCopy();
                book.Type = Book.BookType.BookOrTome;
                book.PickUpSound = new FormLinkNullable<ISoundDescriptorGetter>(
                    Skyrim.SoundDescriptor.ITMNoteUp.FormKey
                );
                book.Keywords = new() { Skyrim.Keyword.VendorItemRecipe };

                state.PatchMod.Books.Set(book);
            }

            void createTranslationCOBJ(
                ConstructibleObject baseCOBJ,
                IFormLink<IItemGetter> ingredient,
                IFormLink<IConstructibleGetter> result,
                FormLinkNullable<IKeywordGetter> benchKeyword,
                IFormLink<ISpellGetter> knowledge,
                int ingredientCount,
                int recipeShowCount = 1
            )
            {
                baseCOBJ.CreatedObject = result.AsNullable();

                baseCOBJ.Items = new ExtendedList<ContainerEntry>
                {
                    new ContainerEntry()
                    {
                        Item = new ContainerItem() { Item = ingredient, Count = ingredientCount },
                    }
                };
                baseCOBJ.WorkbenchKeyword = benchKeyword;
                baseCOBJ.CreatedObjectCount = 1;

                // Add conditions (so it doesn't clutter the menu)
                var baseCOBJCond = new GetItemCountConditionData()
                {
                    RunOnType = Condition.RunOnType.Reference,
                    Reference = Skyrim.PlayerRef,
                };

                baseCOBJCond.ItemOrList = new FormLinkOrIndex<IItemOrListGetter>(
                    baseCOBJCond,
                    ingredient.FormKey
                );

                baseCOBJCond.ItemOrList.Link.SetTo(ingredient.FormKey);

                baseCOBJ.Conditions.Add(
                    new ConditionFloat()
                    {
                        ComparisonValue = recipeShowCount,
                        CompareOperator = CompareOperator.GreaterThanOrEqualTo,
                        Data = baseCOBJCond
                    }
                );

                // Add conditions (so it doesn't clutter the menu)
                if (Settings.HideOnceUnlocked)
                {
                    var knowledgeCondData = new HasSpellConditionData()
                    {
                        RunOnType = Condition.RunOnType.Reference,
                        Reference = Skyrim.PlayerRef,
                    };

                    knowledgeCondData.Spell = new FormLinkOrIndex<ISpellGetter>(
                        knowledgeCondData,
                        knowledge.FormKey
                    );
                    knowledgeCondData.Spell.Link.SetTo(knowledge);

                    var knowledgeCond = new ConditionFloat()
                    {
                        ComparisonValue = 0,
                        CompareOperator = CompareOperator.EqualTo,
                        Data = knowledgeCondData
                    };

                    baseCOBJ.Conditions.Add(knowledgeCond);
                }
            }
            ;

            foreach (var partEntry in Settings.PartList)
            {
                foreach (var part in partEntry.List)
                {
                    if (!partListUniques.Keys.Contains(part.Name))
                        partListUniques.Add(part.Name, part);
                }
            }

            foreach (var partBench in partListUniques)
            {
                var bench = Settings.BenchSettings.First(e =>
                    e.Value.doesTemperOnly == false
                    && e.Key.FormKey == partBench.Value.Bench.FormKey
                );
                if (!benchKeywordSwap.ContainsKey(bench.Key.FormKey))
                    benchKeywordSwap.Add(bench.Key.FormKey, new());

                if (!benchKeywordSwap[bench.Key.FormKey].ContainsKey("study"))
                    GenerateCustomMenu(
                        bench.Key,
                        "study",
                        bench.Value.BenchName,
                        bench.Value.ProcessName,
                        bench.Value.SchematicTypeName,
                        bench.Value.BenchMenuStatic.AsNullable(),
                        Settings.giveSmithingExp
                    );

                if (!benchKeywordSwap[bench.Key.FormKey].ContainsKey("break"))
                    GenerateCustomMenu(
                        bench.Key,
                        "break",
                        bench.Value.BenchName,
                        bench.Value.ProcessName,
                        bench.Value.SchematicTypeName,
                        bench.Value.BenchMenuStatic.AsNullable(),
                        Settings.giveSmithingExp
                    );
            }

            foreach (var material in Settings.MaterialWhitelist)
            {
                partDict.Add(material.Key, new());

                foreach (string partName in partListUniques.Keys)
                {
                    string materialPartName = $"{material.Key} {partName}";
                    string materialPartEditorID = materialPartName.Replace(" ", "");

                    // create a new book
                    Book book =
                        new(state.PatchMod)
                        {
                            EditorID = $"{materialPartEditorID}_Schematic",
                            Name = $"{materialPartName} - Part Schematic",
                            Description =
                                $"A schematic describing the process of crafting a {materialPartName}. I should read this to memorize it — or perhaps I can sell it instead...",
                            Value = 10,
                            Weight = 0.25f,
                        };
                    applyBookDefaults(materialPartName, book);

                    // Create the knowledge "perk"
                    Spell knowledge =
                        new(state.PatchMod)
                        {
                            EditorID = $"{materialPartEditorID}_Knowledge",
                            Name = $"{materialPartName} - Part Knowledge",
                            MenuDisplayObject = book.InventoryArt,
                            ObjectBounds = book.ObjectBounds,
                            EquipmentType = new FormLinkNullable<IEquipTypeGetter>(
                                Skyrim.EquipType.EitherHand.FormKey
                            ),
                            Type = SpellType.Ability,
                            CastType = CastType.ConstantEffect,
                            TargetType = TargetType.Self,
                        };
                    state.PatchMod.Spells.Set(knowledge);
                    book.Teaches = new BookSpell() { Spell = knowledge.ToLink<ISpellGetter>() };

                    // Create the knowledge "perk" mgef
                    MagicEffect knowledgeMGEF =
                        new(state.PatchMod)
                        {
                            EditorID = $"{materialPartEditorID}_KnowledgeMGEF",
                            Name = $"{materialPartName} - Part Knowledge",
                            MenuDisplayObject = book.InventoryArt,
                            Flags = MagicEffect.Flag.NoMagnitude,
                            CastType = CastType.ConstantEffect,
                            TargetType = TargetType.Self,
                            EquipAbility = new FormLinkNullable<ISpellGetter>(knowledge),
                        };
                    if (Settings.HideKnowledgeUI)
                        knowledgeMGEF.Flags |= MagicEffect.Flag.HideInUI;
                    state.PatchMod.MagicEffects.Set(knowledgeMGEF);

                    knowledge.Effects.Add(
                        new Effect() { BaseEffect = knowledgeMGEF.ToNullableLink(), }
                    );

                    // create a new book
                    Book bookFragment =
                        new(state.PatchMod)
                        {
                            EditorID = $"{book.EditorID}_Fragment",
                            Name = $"{materialPartName} - Part Notes",
                            Description =
                                $"My notes on the crafting process of a {materialPartName}.¨If I collect a few more I can perhaps combine them into a schematic...",
                            Value = 2,
                            Weight = 0.10f
                        };
                    applyBookDefaults(materialPartName, bookFragment);

                    // Create COBJ fragment -> book
                    var noteToBookCOBJ = state.PatchMod.ConstructibleObjects.AddNew();

                    createTranslationCOBJ(
                        noteToBookCOBJ,
                        bookFragment.ToLink(),
                        book.ToLink(),
                        new FormLinkNullable<IKeywordGetter>(
                            benchKeywordSwap[partListUniques[partName].Bench.FormKey]["study"]
                        ),
                        knowledge.ToLink(),
                        4
                    );

                    // Create COBJ mats -> fragment
                    var matToNoteCOBJ = state.PatchMod.ConstructibleObjects.AddNew();

                    createTranslationCOBJ(
                        matToNoteCOBJ,
                        material.Value.Ingot,
                        bookFragment.ToLink(),
                        new FormLinkNullable<IKeywordGetter>(
                            benchKeywordSwap[partListUniques[partName].Bench.FormKey]["study"]
                        ),
                        knowledge.ToLink(),
                        3 * partListUniques[partName].Size
                    );

                    // Do not show cobjs if lacking skill
                    if (material.Value.PerkReq != FormLinkGetter<IPerkGetter>.Null)
                    {
                        // Add conditions (so it doesn't clutter the menu)
                        var perkReqCond = new HasPerkConditionData()
                        {
                            RunOnType = Condition.RunOnType.Reference,
                            Reference = Skyrim.PlayerRef,
                        };
                        ;
                        perkReqCond.Perk = new FormLinkOrIndex<IPerkGetter>(
                            perkReqCond,
                            material.Value.PerkReq.FormKey
                        );

                        perkReqCond.Perk.Link.SetTo(material.Value.PerkReq);

                        noteToBookCOBJ.Conditions.Add(
                            new ConditionFloat()
                            {
                                ComparisonValue = 1,
                                CompareOperator = CompareOperator.GreaterThanOrEqualTo,
                                Data = perkReqCond
                            }
                        );

                        matToNoteCOBJ.Conditions.Add(
                            new ConditionFloat()
                            {
                                ComparisonValue = 1,
                                CompareOperator = CompareOperator.GreaterThanOrEqualTo,
                                Data = perkReqCond
                            }
                        );
                    }

                    // Add knowledge spell to part dict then add knowledge and book to separate dict
                    partDict[material.Key].Add(partName, knowledge.FormKey);
                    bookKnowledge.Add(
                        knowledge.FormKey,
                        new()
                        {
                            book.FormKey,
                            bookFragment.FormKey,
                            noteToBookCOBJ.FormKey,
                            matToNoteCOBJ.FormKey
                        }
                    );

                    if (Settings.ShowDebugLogs)
                    {
                        Console.WriteLine(
                            $"Created {knowledge.Name}, {book.Name}, and {bookFragment.Name}"
                        );
                    }
                }
            }

            Console.WriteLine(string.Empty);
            Console.WriteLine("=================================================");
            Console.WriteLine(string.Empty);
            Console.WriteLine("Identifying parts ...");
            Console.WriteLine(string.Empty);

            foreach (
                IConstructibleObjectGetter baseCOBJ in state
                    .LoadOrder.PriorityOrder.ConstructibleObject()
                    .WinningOverrides()
            )
            {
                // Sanity checks to skip unnecessary processing
                if (
                    baseCOBJ.Items == null
                    || !Settings.BenchSettings.Any(e =>
                        e.Key.FormKey == baseCOBJ.WorkbenchKeyword.FormKey
                    )
                    || !baseCOBJ.CreatedObject.TryResolve(state.LinkCache, out var createdItem)
                    || noValidMats.Contains(createdItem.FormKey)
                    || createdItem is not INamedGetter createdItemName
                    || createdItem is not IKeywordedGetter createdItemKeywords
                    || Settings.ItemBlacklist.Contains(createdItem)
                    || state.PatchMod.ConstructibleObjects.Contains(baseCOBJ)
                )
                    continue;

                if (!itemMaterials.ContainsKey(createdItem.FormKey))
                {
                    if (Settings.ShowDebugLogs)
                    {
                        Console.WriteLine(string.Empty);
                        Console.WriteLine("=======================");
                        Console.WriteLine(string.Empty);
                        Console.WriteLine($"Found new item: {createdItemName.Name}");
                        Console.WriteLine($"Checking for valid materials ...");
                    }
                    foreach (var material in Settings.MaterialWhitelist)
                    {
                        if (createdItemKeywords.Keywords == null)
                            continue;

                        if (
                            createdItemKeywords.Keywords.Any(e =>
                                material.Value.Keywords.Contains(e)
                            )
                            // Jewelry specific check
                            || (
                                createdItemKeywords.Keywords.Contains(Skyrim.Keyword.ArmorJewelry)
                                && baseCOBJ.Items.Any(e =>
                                    e.Item.Item.FormKey == material.Value.Ingot.FormKey
                                )
                            )
                        )
                        {
                            if (!itemMaterials.ContainsKey(createdItem.FormKey))
                            {
                                itemMaterials.Add(createdItem.FormKey, new());
                            }
                            itemMaterials[createdItem.FormKey].Add(material.Key);

                            if (Settings.ShowDebugLogs)
                            {
                                Console.WriteLine($"Found {material.Key}");
                            }
                        }
                    }
                }

                if (itemMaterials.ContainsKey(createdItem.FormKey))
                {
                    if (!itemCOBJs.ContainsKey(createdItem.FormKey))
                        itemCOBJs.Add(createdItem.FormKey, new List<FormKey>());
                    itemCOBJs[createdItem.FormKey].Add(baseCOBJ.FormKey);

                    if (!itemBench.ContainsKey(createdItem.FormKey))
                        itemBench.Add(createdItem.FormKey, baseCOBJ.WorkbenchKeyword.FormKey);

                    if (Settings.ShowDebugLogs)
                    {
                        Console.WriteLine(
                            $"Storing the {baseCOBJ.EditorID} COBJ {createdItemName.Name} connection"
                        );
                    }
                }
                else
                {
                    noValidMats.Add(createdItem.FormKey);
                    if (Settings.ShowDebugLogs)
                    {
                        Console.WriteLine($"No valid materials found, ignoring...");
                    }
                }
            }

            Console.WriteLine($"Found {itemCOBJs.Count} items in total to patch");

            Console.WriteLine(string.Empty);
            Console.WriteLine("=================================================");
            Console.WriteLine(string.Empty);
            Console.WriteLine("Generating design blueprints and assigning parts ...");

            foreach (var createdItemFormKey in itemCOBJs.Keys)
            {
                // Pull created item
                if (
                    !state.LinkCache.TryResolve<IItemGetter>(
                        createdItemFormKey,
                        out var createdItem
                    )
                    || createdItem is not INamedGetter createdItemName
                    || createdItemName.Name == null
                    || createdItem is not IKeywordedGetter createdItemKeywords
                )
                    continue;

                string aAn = "a ";
                if (createdItemName.Name.IndexOfAny(GenData.vowels) == 0)
                    aAn = "an ";
                else if (
                    (createdItemFormKey == Skyrim.MiscItem.LeatherStrips.FormKey)
                    || (createdItemFormKey == Skyrim.MiscItem.Leather01.FormKey)
                )
                    aAn = "";

                if (Settings.ShowDebugLogs)
                {
                    Console.WriteLine(string.Empty);
                    Console.WriteLine("=======================");
                    Console.WriteLine(string.Empty);
                    Console.WriteLine($"Found {createdItemName.Name} ...");
                }
                else
                    Console.WriteLine($"Patching for {createdItemName.Name} ...");

                // creating a new entry in the knowledge req dict to prepare for adding future mats
                itemKnowledgeReq.Add(createdItemFormKey, new());

                // Only create a design blueprint if this is not a basic item
                if (
                    !Settings.BasicItems.Contains(createdItemFormKey)
                    || (
                        createdItemKeywords.Keywords != null
                        && !createdItemKeywords.Keywords.Contains(Skyrim.Keyword.DaedricArtifact)
                    )
                )
                {
                    if (Settings.ShowDebugLogs)
                    {
                        Console.WriteLine($"Generating design schematic ...");
                    }

                    string materialPartName = createdItemName.Name;
                    string materialPartEditorID = materialPartName.Replace(" ", "");

                    // Deterministic seed
                    var random = new Random(materialPartName.GetHashCode());

                    // Randomize book model
                    var bookModelSetKey = GenData.bookModelLib.Keys.ElementAt(
                        (int)
                            Math.Round(
                                (GenData.bookModelLib.Count - 1) * (float)random.NextDouble()
                            )
                    );
                    if (
                        !state.LinkCache.TryResolve<IStaticGetter>(
                            bookModelSetKey,
                            out var bookStatic
                        )
                    )
                        continue;

                    // Randomize fragment model
                    var bookFragmentModelSetKey = GenData.bookFragmentModelLib.Keys.ElementAt(
                        (int)
                            Math.Round(
                                (GenData.bookFragmentModelLib.Count - 1)
                                    * (float)random.NextDouble()
                            )
                    );
                    if (
                        !state.LinkCache.TryResolve<IStaticGetter>(
                            bookFragmentModelSetKey,
                            out var bookFragmentStatic
                        )
                    )
                        continue;

                    // Create the knowledge "perk"
                    Spell knowledge = state.PatchMod.Spells.AddNew();

                    knowledge.EditorID = $"{materialPartEditorID}Knowledge";
                    knowledge.Name = $"{materialPartName} - Assembly Knowledge";
                    knowledge.MenuDisplayObject = new FormLinkNullable<IStaticGetter>(bookStatic);
                    knowledge.ObjectBounds = bookStatic.ObjectBounds.DeepCopy();
                    knowledge.EquipmentType = new FormLinkNullable<IEquipTypeGetter>(
                        Skyrim.EquipType.EitherHand.FormKey
                    );
                    knowledge.Type = SpellType.Ability;
                    knowledge.CastType = CastType.ConstantEffect;
                    knowledge.TargetType = TargetType.Self;

                    // Create the knowledge "perk" mgef
                    MagicEffect knowledgeMGEF = state.PatchMod.MagicEffects.AddNew();

                    knowledgeMGEF.EditorID = $"{materialPartEditorID}KnowledgeMGEF";
                    knowledgeMGEF.Name = $"{materialPartName} - Assembly Knowledge";
                    knowledgeMGEF.Description = $"I now know how to craft {materialPartName}";
                    knowledgeMGEF.MenuDisplayObject = new FormLinkNullable<IStaticGetter>(
                        bookStatic
                    );
                    if (Settings.HideKnowledgeUI)
                        knowledgeMGEF.Flags = MagicEffect.Flag.HideInUI;
                    knowledgeMGEF.CastType = CastType.ConstantEffect;
                    knowledgeMGEF.TargetType = TargetType.Self;
                    knowledgeMGEF.EquipAbility = new FormLinkNullable<ISpellGetter>(knowledge);
                    ;

                    knowledge.Effects.Add(
                        new Effect()
                        {
                            BaseEffect = new FormLinkNullable<IMagicEffectGetter>(knowledgeMGEF),
                            Data = new() { Magnitude = 1f }
                        }
                    );

                    // create a new book
                    Book book = state.PatchMod.Books.AddNew();

                    // Set the book properties
                    book.EditorID = $"{materialPartEditorID}Schematic";
                    book.Name = $"{materialPartName} - Assembly Schematic";
                    book.Description =
                        $"A schematic describing the Design of {aAn}{materialPartName}. I should read this to memorize it — or perhaps I can sell it instead...";
                    book.Value = 10;
                    book.Weight = 0.25f;
                    book.Model = GenData.bookModelLib[bookModelSetKey];
                    book.InventoryArt = new FormLinkNullable<IStaticGetter>(bookStatic);
                    book.ObjectBounds = bookStatic.ObjectBounds.DeepCopy();
                    book.Type = Book.BookType.BookOrTome;
                    book.PickUpSound = new FormLinkNullable<ISoundDescriptorGetter>(
                        Skyrim.SoundDescriptor.ITMNoteUp.FormKey
                    );
                    book.Keywords = new ExtendedList<IFormLinkGetter<IKeywordGetter>>
                    {
                        Skyrim.Keyword.VendorItemRecipe
                    };
                    book.Teaches = new BookSpell() { Spell = knowledge.ToLink<ISpellGetter>() };

                    // create a new book
                    Book bookFragment = state.PatchMod.Books.AddNew();

                    // Set the book properties
                    bookFragment.EditorID = $"{book.EditorID}Fragment";
                    bookFragment.Name = $"{materialPartName} - Assembly Notes";
                    bookFragment.Description =
                        $"My notes on the crafting process of {aAn}{materialPartName}.¨If I collect a few more I can perhaps combine them into a schematic...";
                    bookFragment.Value = 2;
                    bookFragment.Weight = 0.10f;
                    bookFragment.Model = GenData.bookModelLib[bookModelSetKey];
                    bookFragment.InventoryArt = new FormLinkNullable<IStaticGetter>(bookStatic);
                    bookFragment.ObjectBounds = bookStatic.ObjectBounds.DeepCopy();
                    bookFragment.Type = Book.BookType.BookOrTome;
                    bookFragment.PickUpSound = new FormLinkNullable<ISoundDescriptorGetter>(
                        Skyrim.SoundDescriptor.ITMNoteUp.FormKey
                    );
                    bookFragment.Keywords = new ExtendedList<IFormLinkGetter<IKeywordGetter>>
                    {
                        Skyrim.Keyword.VendorItemRecipe
                    };

                    // Create COBJ fragment -> book
                    var noteToBookCOBJ = state.PatchMod.ConstructibleObjects.AddNew();

                    noteToBookCOBJ.EditorID = $"{materialPartEditorID}Recipe";
                    noteToBookCOBJ.CreatedObject = new FormLinkNullable<IConstructibleGetter>(
                        book.FormKey
                    );

                    noteToBookCOBJ.Items = new ExtendedList<ContainerEntry>
                    {
                        new ContainerEntry()
                        {
                            Item = new ContainerItem()
                            {
                                Item = new FormLink<IItemGetter>(bookFragment.FormKey),
                                Count = 3
                            },
                        }
                    };
                    noteToBookCOBJ.WorkbenchKeyword = new FormLinkNullable<IKeywordGetter>(
                        benchKeywordSwap[itemBench[createdItemFormKey]]["study"]
                    );
                    noteToBookCOBJ.CreatedObjectCount = 1;

                    // Add conditions (so it doesn't clutter the menu)
                    var noteToBookCOBJCond = new GetItemCountConditionData()
                    {
                        RunOnType = Condition.RunOnType.Reference,
                        Reference = Skyrim.PlayerRef,
                    };
                    ;
                    noteToBookCOBJCond.ItemOrList = new FormLinkOrIndex<IItemOrListGetter>(
                        noteToBookCOBJCond,
                        bookFragment.FormKey
                    );
                    noteToBookCOBJCond.ItemOrList.Link.SetTo(bookFragment);

                    noteToBookCOBJ.Conditions.Add(
                        new ConditionFloat()
                        {
                            ComparisonValue = 1,
                            CompareOperator = CompareOperator.GreaterThanOrEqualTo,
                            Data = noteToBookCOBJCond
                        }
                    );

                    // Breakdown Recipe
                    var itemToBookCOBJ = state.PatchMod.ConstructibleObjects.AddNew();

                    itemToBookCOBJ.EditorID = $"{materialPartEditorID}BreakdownRecipe";
                    itemToBookCOBJ.CreatedObject = new FormLinkNullable<IConstructibleGetter>(book);

                    itemToBookCOBJ.Items = new ExtendedList<ContainerEntry>
                    {
                        new ContainerEntry()
                        {
                            Item = new ContainerItem()
                            {
                                Item = new FormLink<IItemGetter>(createdItemFormKey),
                                Count = 1
                            },
                        }
                    };

                    itemToBookCOBJ.WorkbenchKeyword = new FormLinkNullable<IKeywordGetter>(
                        benchKeywordSwap[itemBench[createdItemFormKey]]["break"]
                    );
                    itemToBookCOBJ.CreatedObjectCount = 1;

                    // Add conditions (so it doesn't clutter the menu)
                    var itemToBookCOBJCond = new GetItemCountConditionData()
                    {
                        RunOnType = Condition.RunOnType.Reference,
                        Reference = Skyrim.PlayerRef,
                    };
                    ;
                    itemToBookCOBJCond.ItemOrList = new FormLinkOrIndex<IItemOrListGetter>(
                        itemToBookCOBJCond,
                        createdItemFormKey
                    );
                    itemToBookCOBJCond.ItemOrList.Link.SetTo(createdItemFormKey);

                    itemToBookCOBJ.Conditions.Add(
                        new ConditionFloat()
                        {
                            ComparisonValue = 1,
                            CompareOperator = CompareOperator.GreaterThanOrEqualTo,
                            Data = itemToBookCOBJCond
                        }
                    );

                    // Create COBJ mats -> fragment
                    var matToNoteCOBJ = state.PatchMod.ConstructibleObjects.AddNew();

                    matToNoteCOBJ.EditorID = $"{materialPartEditorID}RecipeFragment";
                    matToNoteCOBJ.CreatedObject = new FormLinkNullable<IConstructibleGetter>(
                        bookFragment.FormKey
                    );

                    matToNoteCOBJ.Items = new ExtendedList<ContainerEntry>();

                    matToNoteCOBJ.WorkbenchKeyword = new FormLinkNullable<IKeywordGetter>(
                        benchKeywordSwap[itemBench[createdItemFormKey]]["break"]
                    );
                    matToNoteCOBJ.CreatedObjectCount = (ushort?)matToNoteCOBJ.Items.Count;

                    foreach (var materialName in itemMaterials[createdItemFormKey])
                    {
                        var material = Settings.MaterialWhitelist.First(e => e.Key == materialName);

                        matToNoteCOBJ.Items.Add(
                            new()
                            {
                                Item = new()
                                {
                                    Item = new FormLink<IItemGetter>(material.Value.Ingot.FormKey),
                                    Count = 1
                                }
                            }
                        );

                        // Add conditions (so it doesn't clutter the menu)
                        var matToNoteCOBJCond = new GetItemCountConditionData()
                        {
                            RunOnType = Condition.RunOnType.Reference,
                            Reference = Skyrim.PlayerRef,
                        };
                        ;
                        matToNoteCOBJCond.ItemOrList = new FormLinkOrIndex<IItemOrListGetter>(
                            matToNoteCOBJCond,
                            material.Value.Ingot.FormKey
                        );
                        matToNoteCOBJCond.ItemOrList.Link.SetTo(material.Value.Ingot.FormKey);

                        matToNoteCOBJ.Conditions.Add(
                            new ConditionFloat()
                            {
                                ComparisonValue = 1,
                                CompareOperator = CompareOperator.GreaterThanOrEqualTo,
                                Data = matToNoteCOBJCond
                            }
                        );
                    }

                    // Do not show cobjs if lacking skill
                    if (
                        state.LinkCache.TryResolve<IConstructibleObjectGetter>(
                            itemCOBJs[createdItemFormKey][0],
                            out var initialCOBJ
                        )
                    )
                        foreach (var cond in initialCOBJ.Conditions)
                        {
                            noteToBookCOBJ.Conditions.Add(cond.DeepCopy());
                            itemToBookCOBJ.Conditions.Add(cond.DeepCopy());
                            matToNoteCOBJ.Conditions.Add(cond.DeepCopy());
                        }

                    // Add knowledge spell to part dict then add knowledge and book to separate dict
                    bookKnowledge.Add(
                        knowledge.FormKey,
                        new()
                        {
                            book.FormKey,
                            bookFragment.FormKey,
                            noteToBookCOBJ.FormKey,
                            itemToBookCOBJ.FormKey,
                            matToNoteCOBJ.FormKey
                        }
                    );

                    // Add conditions (so it doesn't clutter the menu)
                    if (Settings.HideOnceUnlocked)
                    {
                        var knowledgeCondData = new HasSpellConditionData()
                        {
                            RunOnType = Condition.RunOnType.Reference,
                            Reference = Skyrim.PlayerRef,
                        };

                        knowledgeCondData.Spell = new FormLinkOrIndex<ISpellGetter>(
                            knowledgeCondData,
                            knowledge.FormKey
                        );
                        knowledgeCondData.Spell.Link.SetTo(knowledge);

                        var knowledgeCond = new ConditionFloat()
                        {
                            ComparisonValue = 0,
                            CompareOperator = CompareOperator.EqualTo,
                            Data = knowledgeCondData
                        };

                        itemToBookCOBJ.Conditions.Add(knowledgeCond);
                        noteToBookCOBJ.Conditions.Add(knowledgeCond);
                        matToNoteCOBJ.Conditions.Add(knowledgeCond);
                    }

                    if (Settings.ShowDebugLogs)
                    {
                        Console.WriteLine($"Created item design perk: {knowledge.Name}");
                        Console.WriteLine($"Created item design book (gives perk): {book.Name}");
                        Console.WriteLine(
                            $"Created item design book fragment (gives book): {bookFragment.Name}"
                        );
                        Console.WriteLine($"-------------------------------");
                    }

                    // Add to req list
                    itemKnowledgeReq[createdItemFormKey].Add(knowledge.FormKey);

                    // Add to temp list to avoid removal
                    safeToKeepKnowledge.Add(knowledge.FormKey);
                }
                else if (Settings.ShowDebugLogs)
                {
                    Console.WriteLine($"Basic item, skipping design schematic");
                }

                // Assigning the parts
                if (createdItemKeywords.Keywords != null)
                    // loop through all part keywords, eg: light helmet, etc. skip if not valid
                    foreach (var partKey in Settings.PartList)
                    {
                        if (!partKey.Keywords.All(e => createdItemKeywords.Keywords.Contains(e)))
                            continue;

                        foreach (var material in itemMaterials[createdItemFormKey])
                        {
                            foreach (var part in partKey.List)
                            {
                                if (
                                    !createdItemKeywords.Keywords.Contains(
                                        Skyrim.Keyword.DaedricArtifact
                                    )
                                )
                                {
                                    var itemToBookCOBJ =
                                        state.PatchMod.ConstructibleObjects.AddNew();

                                    itemToBookCOBJ.EditorID =
                                        $"{createdItemName.Name.Replace(" ", "")}{part.Name.Replace(" ", "")}BreakdownRecipe";
                                    itemToBookCOBJ.CreatedObject =
                                        new FormLinkNullable<IConstructibleGetter>(
                                            bookKnowledge[partDict[material][part.Name]][0]
                                        );

                                    itemToBookCOBJ.Items = new ExtendedList<ContainerEntry>
                                    {
                                        new ContainerEntry()
                                        {
                                            Item = new ContainerItem()
                                            {
                                                Item = new FormLink<IItemGetter>(
                                                    createdItemFormKey
                                                ),
                                                Count = 1
                                            },
                                        }
                                    };
                                    itemToBookCOBJ.WorkbenchKeyword =
                                        new FormLinkNullable<IKeywordGetter>(
                                            benchKeywordSwap[itemBench[createdItemFormKey]]["break"]
                                        );
                                    itemToBookCOBJ.CreatedObjectCount = 1;

                                    // Add conditions (so it doesn't clutter the menu)
                                    var itemToBookCOBJCond = new GetItemCountConditionData()
                                    {
                                        RunOnType = Condition.RunOnType.Reference,
                                        Reference = Skyrim.PlayerRef,
                                    };
                                    ;
                                    itemToBookCOBJCond.ItemOrList =
                                        new FormLinkOrIndex<IItemOrListGetter>(
                                            itemToBookCOBJCond,
                                            createdItemFormKey
                                        );
                                    itemToBookCOBJCond.ItemOrList.Link.SetTo(createdItemFormKey);

                                    itemToBookCOBJ.Conditions.Add(
                                        new ConditionFloat()
                                        {
                                            ComparisonValue = 1,
                                            CompareOperator = CompareOperator.GreaterThanOrEqualTo,
                                            Data = itemToBookCOBJCond
                                        }
                                    );

                                    // Do not show cobjs if lacking skill
                                    if (
                                        state.LinkCache.TryResolve<IConstructibleObjectGetter>(
                                            itemCOBJs[createdItemFormKey][0],
                                            out var initialCOBJ
                                        )
                                    )
                                        foreach (var cond in initialCOBJ.Conditions)
                                        {
                                            itemToBookCOBJ.Conditions.Add(cond.DeepCopy());
                                        }
                                }

                                // Add item to knowledge req
                                itemKnowledgeReq[createdItemFormKey]
                                    .Add(partDict[material][part.Name]);

                                if (Settings.ShowDebugLogs)
                                {
                                    Console.WriteLine($"Found {part.Name}");
                                }

                                // Add to temp list to avoid removal
                                safeToKeepKnowledge.Add(partDict[material][part.Name]);
                            }
                        }
                    }

                foreach (FormKey cobjFormKey in itemCOBJs[createdItemFormKey])
                {
                    // Define COBJ
                    if (
                        !state.LinkCache.TryResolve<IConstructibleObjectGetter>(
                            cobjFormKey,
                            out var cobj
                        )
                    )
                        continue;

                    var modifiedCOBJ = state.PatchMod.ConstructibleObjects.GetOrAddAsOverride(cobj);

                    foreach (var knowledge in itemKnowledgeReq[createdItemFormKey])
                    {
                        // Add conditions (so it doesn't clutter the menu)
                        var knowledgeCondData = new HasSpellConditionData()
                        {
                            RunOnType = Condition.RunOnType.Reference,
                            Reference = Skyrim.PlayerRef,
                        };
                        ;
                        knowledgeCondData.Spell = new FormLinkOrIndex<ISpellGetter>(
                            knowledgeCondData,
                            knowledge
                        );
                        knowledgeCondData.Spell.Link.SetTo(knowledge);

                        modifiedCOBJ.Conditions.Add(
                            new ConditionFloat()
                            {
                                ComparisonValue = 1,
                                CompareOperator = CompareOperator.GreaterThanOrEqualTo,
                                Data = knowledgeCondData
                            }
                        );
                    }
                }
                ;

                if (Settings.ShowDebugLogs)
                {
                    Console.WriteLine(string.Empty);
                    Console.WriteLine($"Patching LVLIs to include new schematics ...");
                }

                foreach (FormKey lvliFormKey in LootLVLIWhitelist)
                {
                    // Define LVLI and check if it's empty
                    if (
                        !state.LinkCache.TryResolve<ILeveledItemGetter>(
                            lvliFormKey,
                            out var leveledList
                        )
                        || leveledList.Entries == null
                    )
                        continue;

                    LeveledItem modifiedLVLI = leveledList.DeepCopy();

                    var itemList = modifiedLVLI.Entries;
                    if (itemList == null)
                        continue;

                    int modifiedCount = 0;

                    foreach (var LVLIEntry in itemList)
                    {
                        // Sanity checks to skip unnecessary processing
                        if (LVLIEntry.Data == null || LVLIEntry.Data.Reference == null)
                            continue;

                        if (LVLIEntry.Data.Reference.FormKey != createdItemFormKey)
                            continue;

                        if (!itemLVLIEntries.Keys.Contains(createdItemFormKey))
                        {
                            if (Settings.ShowDebugLogs)
                            {
                                Console.WriteLine($"Creating subLVLI ...");
                            }

                            LeveledItem itemLVLI = state.PatchMod.LeveledItems.AddNew();

                            itemLVLI.ChanceNone = 0;
                            itemLVLI.EditorID =
                                $"{createdItemName.Name.Replace(" ", "")}WithSchematicsLVLI";
                            itemLVLI.Entries = new ExtendedList<LeveledItemEntry>();

                            // add the item first
                            LeveledItemEntry itemEntry = new LeveledItemEntry()
                            {
                                Data = new LeveledItemEntryData()
                                {
                                    Reference = new FormLink<IItemGetter>(createdItem),
                                    Level = 1,
                                    Count = 1
                                }
                            };

                            for (int i = 0; i < 8; i++)
                            {
                                itemLVLI.Entries.Add(itemEntry);
                            }

                            foreach (var spell in itemKnowledgeReq[createdItemFormKey])
                            {
                                // Define LVLI and check if it's empty
                                if (
                                    !state.LinkCache.TryResolve<ISpellGetter>(
                                        spell,
                                        out var knowledge
                                    )
                                )
                                    continue;

                                // basic book entry to be added to schematicLVLI
                                LeveledItemEntry bookEntry = new LeveledItemEntry()
                                {
                                    Data = new LeveledItemEntryData()
                                    {
                                        Reference = new FormLink<IItemGetter>(
                                            bookKnowledge[spell][0]
                                        ),
                                        Level = 1,
                                        Count = 1
                                    }
                                };

                                itemLVLI.Entries.Add(bookEntry);

                                // basic book entry to be added to schematicLVLI
                                LeveledItemEntry bookFragmentEntry = new LeveledItemEntry()
                                {
                                    Data = new LeveledItemEntryData()
                                    {
                                        Reference = new FormLink<IItemGetter>(
                                            bookKnowledge[spell][1]
                                        ),
                                        Level = 1,
                                        Count = 1
                                    }
                                };

                                for (int i = 0; i < 3; i++)
                                {
                                    itemLVLI.Entries.Add(bookFragmentEntry);
                                }
                            }
                            itemLVLIEntries.Add(createdItemFormKey, itemLVLI.FormKey);
                        }

                        if (Settings.ShowDebugLogs)
                        {
                            Console.WriteLine(
                                $"{modifiedLVLI.EditorID}: Found a {LVLIEntry.Data.Count} x lvl {LVLIEntry.Data.Level} {createdItemName.Name} entry"
                            );
                        }

                        modifiedCount++;
                        LVLIEntry.Data.Reference = new FormLink<ILeveledItemGetter>(
                            itemLVLIEntries[createdItemFormKey]
                        );
                    }

                    if (modifiedCount != 0)
                        state.PatchMod.LeveledItems.Set(modifiedLVLI);
                }
            }

            Console.WriteLine(string.Empty);
            Console.WriteLine("=================================================");
            Console.WriteLine(string.Empty);
            Console.WriteLine("Cleaning up unused parts ...");

            foreach (var material in Settings.MaterialWhitelist)
            {
                foreach (string partName in partListUniques.Keys)
                {
                    var knowledge = partDict[material.Key][partName];
                    if (!state.LinkCache.TryResolve<ISpellGetter>(knowledge, out var knowledgeRef))
                        continue;

                    if (!safeToKeepKnowledge.Contains(knowledge))
                    {
                        state.PatchMod.Books.Remove(bookKnowledge[knowledge][0]);
                        state.PatchMod.Books.Remove(bookKnowledge[knowledge][1]);
                        state.PatchMod.ConstructibleObjects.Remove(bookKnowledge[knowledge][2]);
                        state.PatchMod.ConstructibleObjects.Remove(bookKnowledge[knowledge][3]);
                        state.PatchMod.MagicEffects.Remove(
                            knowledgeRef.Effects[0].BaseEffect.FormKey
                        );
                        state.PatchMod.Spells.Remove(knowledge);
                        Console.WriteLine($"Removed {material.Key} {partName}");
                    }
                }
            }

            Console.WriteLine(string.Empty);
            Console.WriteLine("=================================================");
        }
    }
}
