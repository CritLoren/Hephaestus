using System.Runtime.InteropServices;
using Mutagen.Bethesda;
using Mutagen.Bethesda.FormKeys.SkyrimSE;
using Mutagen.Bethesda.Plugins;
using Mutagen.Bethesda.Plugins.Aspects;
using Mutagen.Bethesda.Plugins.Records;
using Mutagen.Bethesda.Skyrim;
using Mutagen.Bethesda.Synthesis;
using Noggog;

namespace Hephaestus
{
    // To do
    // refactor code, too much duplicated initializations of books, book fragments, conds, etc.
    // Dialogue options to blacksmiths to tell you about each item type and what it can craft? Even better, have two powers, one for breaking down (Research) and another for drawing up schematics (putting them together; Drawing)

    public class Program
    {
        static Lazy<Settings> _settings = null!;
        public static Settings Settings => _settings.Value;

        public static async Task<int> Main(string[] args)
        {
            // Run the patcher
            return await SynthesisPipeline
                .Instance.AddPatch<ISkyrimMod, ISkyrimModGetter>(RunPatch)
                .SetTypicalOpen(GameRelease.SkyrimSE, "Hephaestus.esp")
                .SetAutogeneratedSettings("Settings", "settings.json", out _settings)
                .Run(args);
        }

        private static void RunPatch(IPatcherState<ISkyrimMod, ISkyrimModGetter> state)
        {
            // SECTION - Variable Initialization

            // ANCHOR - Initialising dictionaries and lists
            Dictionary<string, PartData> partListUniques = new();
            Dictionary<string, Dictionary<string, FormKey>> partDict = new();
            Dictionary<FormKey, List<FormKey>> bookKnowledge = new();
            Dictionary<FormKey, List<FormKey>> itemCOBJs = new();
            Dictionary<FormKey, List<FormKey>> itemKnowledgeReq = new();
            Dictionary<FormKey, List<string>> itemMaterials = new();
            Dictionary<FormKey, FormKey> itemBench = new();
            Dictionary<string, FormKey> breakStudyKeywords = new();
            List<FormKey> noValidMats = new();
            List<FormKey> safeToKeepKnowledge = new();
            Dictionary<FormKey, FormKey> itemLVLIEntries = new();

            Console.WriteLine(string.Empty);
            Console.WriteLine("=================================================");
            Console.WriteLine(string.Empty);
            Console.WriteLine("Prep phase ...");
            Console.WriteLine(string.Empty);

            // ANCHOR - Combining LVLIs based on settings
            List<FormKey> LootLVLIWhitelist = new();
            LootLVLIWhitelist.AddRange(GenData.LootLVLIWhitelistBase);
            if (Settings.DistributeVendors)
                LootLVLIWhitelist.AddRange(GenData.LootLVLIWhitelistVendor);
            if (Settings.DistributeBlacksmiths)
                LootLVLIWhitelist.AddRange(GenData.LootLVLIWhitelistBlacksmith);
            if (Settings.DistributeSpecial)
                LootLVLIWhitelist.AddRange(GenData.LootLVLIWhitelistSpecial);

            // ANCHOR - Copying the menu script (if necessary)
            string sourcePath = state.RetrieveInternalFile("_camp_craftingobjecteffectscript.pex");
            string destPath = Path.Combine(
                state.DataFolderPath,
                "Scripts",
                "_camp_craftingobjecteffectscript.pex"
            );
            if (!File.Exists(destPath))
                File.Copy(sourcePath, destPath, true);

            // ANCHOR - Creating generic mounted message for script
            Message mountedMessage =
                new(state.PatchMod)
                {
                    EditorID = "HephaestusMountedMessage",
                    Description = "You cannot research while mounted.",
                    DisplayTime = 2,
                };
            state.PatchMod.Messages.Set(mountedMessage);

            // ANCHOR - Creating quest for start game distribution
            Quest hephaestusStartGameGiver =
                new(state.PatchMod)
                {
                    EditorID = "Hephaestus_StartGameDistributor",
                    Flags = Quest.Flag.StartGameEnabled,
                    Stages = new()
                    {
                        new() { Index = 0, Flags = QuestStage.Flag.StartUpStage }
                    },
                    Aliases = new()
                    {
                        new() { ForcedReference = Skyrim.PlayerRef.AsNullable(), Spells = new() }
                    }
                };
            state.PatchMod.Quests.Set(hephaestusStartGameGiver);

            // ANCHOR - Creating space to place menu furniture
            var overrideCell = state
                .LinkCache.ResolveContext<ICell, ICellGetter>(Skyrim.Cell.QASmoke.FormKey)
                .GetOrAddAsOverride(state.PatchMod);

            // !SECTION
            // SECTION - Helpers

            // ANCHOR - Generate Custom Menu
            void GenerateCustomMenu(
                string processType,
                string description,
                IFormLinkNullable<IStaticGetter> menuStatic,
                bool giveSmithingExp
            )
            {
                string benchName = $"Portable Crafting Kit - {processType}";
                string benchEditorID = $"Portable Crafting Kit - {processType}";

                // Create the keyword
                Keyword benchKeyword = state.PatchMod.Keywords.AddNew();
                benchKeyword.EditorID = $"{benchEditorID}_Keyword";

                Furniture customMenuFurniture =
                    new(state.PatchMod)
                    {
                        Name = benchName,
                        EditorID = $"{benchEditorID}_Furniture",
                        Model = new() { File = "Furniture\\SitCrossLeggedMarker.nif" },
                        InteractionKeyword = new FormLinkNullable<IKeywordGetter>(
                            Skyrim.Keyword.ActorTypeNPC.FormKey
                        ),
                        Flags = Furniture.Flag.MustExitToTalk,
                        WorkbenchData = new() { BenchType = WorkbenchData.Type.CreateObject, },
                        Keywords = new() { benchKeyword }
                    };
                if (giveSmithingExp)
                    customMenuFurniture.WorkbenchData.UsesSkill = Skill.Smithing;
                state.PatchMod.Furniture.Set(customMenuFurniture);

                // place the furniture
                PlacedObject customMenuPlacedReference =
                    new(state.PatchMod)
                    {
                        EditorID = $"{benchEditorID}_Reference",
                        Base = customMenuFurniture.ToNullableLink(),
                        Placement = new()
                        {
                            Position = new()
                            {
                                X = 0,
                                Y = 0,
                                Z = -3000
                            },
                            Rotation = new()
                            {
                                X = 0,
                                Y = 0,
                                Z = 0
                            }
                        }
                    };
                overrideCell.Temporary.Add(customMenuPlacedReference);

                // Create the furniture effect
                MagicEffect customMenuScriptDummy =
                    new(state.PatchMod)
                    {
                        EditorID = $"{benchEditorID}_ScriptDummy",
                        MenuDisplayObject = Skyrim.Static.BlacksmithAnvilStatic.AsNullable(),
                        CastType = CastType.FireAndForget,
                        TargetType = TargetType.Self,
                        Flags =
                            MagicEffect.Flag.HideInUI
                            | MagicEffect.Flag.NoDuration
                            | MagicEffect.Flag.NoMagnitude
                            | MagicEffect.Flag.NoArea,
                        CastingSoundLevel = SoundLevel.Loud,
                        VirtualMachineAdapter = new()
                        {
                            Version = 5,
                            ObjectFormat = 2,
                            Scripts = new()
                            {
                                new ScriptEntry()
                                {
                                    Name = "_Camp_CraftingObjectEffectScript",
                                    Flags = ScriptEntry.Flag.Local,
                                    Properties = new()
                                    {
                                        new ScriptObjectProperty()
                                        {
                                            Name = "PlayerRef",
                                            Flags = ScriptProperty.Flag.Edited,
                                            Object = Skyrim.PlayerRef
                                        },
                                        new ScriptObjectProperty()
                                        {
                                            Name = "_Camp_CraftingObjectREF",
                                            Flags = ScriptProperty.Flag.Edited,
                                            Object = customMenuPlacedReference.ToNullableLink()
                                        },
                                        new ScriptObjectProperty()
                                        {
                                            Name = "_Camp_GeneralError_Mounted",
                                            Flags = ScriptProperty.Flag.Edited,
                                            Object = mountedMessage.ToNullableLink()
                                        }
                                    }
                                }
                            }
                        }
                    };
                state.PatchMod.MagicEffects.Set(customMenuScriptDummy);

                Spell customMenuSpell =
                    new(state.PatchMod)
                    {
                        EditorID = $"{benchEditorID}_Spell",
                        Name = benchName,
                        Description = description,
                        MenuDisplayObject = menuStatic,
                        EquipmentType = Skyrim.EquipType.Voice.AsNullable(),
                        Type = SpellType.LesserPower,
                        CastType = CastType.FireAndForget,
                        TargetType = TargetType.Self,

                        Effects = new()
                        {
                            new Effect() { BaseEffect = customMenuScriptDummy.ToNullableLink(), }
                        }
                    };
                state.PatchMod.Spells.Set(customMenuSpell);

                breakStudyKeywords.Add(processType, benchKeyword.FormKey);
                hephaestusStartGameGiver.Aliases.First().Spells.Add(customMenuSpell);
            }
            ;

            // ANCHOR - Hide COBJ based on knowledge
            void COBJReqKnowledge(ConstructibleObject baseCOBJ, IFormLink<ISpellGetter> knowledge)
            {
                var knowledgeCondData = new HasSpellConditionData()
                {
                    RunOnType = Condition.RunOnType.Reference,
                    Reference = Skyrim.PlayerRef,
                };

                knowledgeCondData.Spell = new FormLinkOrIndex<ISpellGetter>(
                    knowledgeCondData,
                    knowledge.FormKey
                );
                knowledgeCondData.Spell.Link.SetTo(knowledge);

                var knowledgeCond = new ConditionFloat()
                {
                    ComparisonValue = 0,
                    CompareOperator = CompareOperator.EqualTo,
                    Data = knowledgeCondData
                };

                baseCOBJ.Conditions.Add(knowledgeCond);
            }

            // ANCHOR - Create Conversion COBJs
            void createConversionCOBJs(
                ConstructibleObject baseCOBJ,
                List<IFormLink<IItemGetter>> ingredientList,
                IFormLink<IConstructibleGetter> result,
                string benchKeyword,
                [Optional] IFormLink<ISpellGetter> knowledge,
                int ingredientCount,
                int recipeShowCount = 1
            )
            {
                baseCOBJ.CreatedObject = result.AsNullable();
                baseCOBJ.WorkbenchKeyword = new FormLinkNullable<IKeywordGetter>(
                    breakStudyKeywords[benchKeyword]
                );
                baseCOBJ.CreatedObjectCount = 1;
                baseCOBJ.Items = new ExtendedList<ContainerEntry>();

                foreach (var ingredient in ingredientList)
                {
                    baseCOBJ.Items.Add(
                        new ContainerEntry()
                        {
                            Item = new ContainerItem()
                            {
                                Item = ingredient,
                                Count = (int)
                                    Math.Round(ingredientCount / (double)ingredientList.Count)
                            },
                        }
                    );

                    // Add conditions (so it doesn't clutter the menu)
                    var baseCOBJCond = new GetItemCountConditionData()
                    {
                        RunOnType = Condition.RunOnType.Reference,
                        Reference = Skyrim.PlayerRef,
                    };

                    baseCOBJCond.ItemOrList = new FormLinkOrIndex<IItemOrListGetter>(
                        baseCOBJCond,
                        ingredient.FormKey
                    );

                    baseCOBJCond.ItemOrList.Link.SetTo(ingredient.FormKey);

                    baseCOBJ.Conditions.Add(
                        new ConditionFloat()
                        {
                            ComparisonValue = recipeShowCount,
                            CompareOperator = CompareOperator.GreaterThanOrEqualTo,
                            Data = baseCOBJCond
                        }
                    );
                }

                // Add conditions (so it doesn't clutter the menu)
                if (knowledge != null && Settings.HideOnceUnlocked)
                    COBJReqKnowledge(baseCOBJ, knowledge);
            }
            ;

            // SECTION - Create Schematic Setup
            void createSchematicSetup(
                [Optional] string partName,
                [Optional] string materialName,
                [Optional] IFormLink<IItemGetter> createdItem
            )
            {
                // ANCHOR - Initial checks and value setup
                string createdItemName = string.Empty;
                string createdItemEditorID = createdItemName.Replace(" ", "");

                var material = Settings.MaterialWhitelist["Wood"];
                int matReqCount = 1;
                List<IFormLink<IItemGetter>> ingotList = new();

                if (createdItem == null)
                {
                    createdItemName = $"{materialName} {partName}";
                    material = Settings.MaterialWhitelist[materialName];
                    matReqCount = 3 * partListUniques[partName].Size;
                    ingotList.Add(material.Ingot);
                }
                else
                {
                    if (
                        createdItem is not INamedGetter createdItemNameGetter
                        || createdItemNameGetter.Name == null
                    )
                        return;
                    createdItemName = createdItemNameGetter.Name;
                    foreach (var materialEntry in itemMaterials[createdItem.FormKey])
                        ingotList.Add(Settings.MaterialWhitelist[materialEntry].Ingot);
                }

                string aAn = "a ";
                if (createdItemName.IndexOfAny(GenData.vowels) == 0)
                    aAn = "an ";
                else if (
                    (
                        createdItem != null
                        && (
                            createdItem.FormKey == Skyrim.MiscItem.LeatherStrips.FormKey
                            || createdItem.FormKey == Skyrim.MiscItem.Leather01.FormKey
                        )
                    )
                )
                    aAn = "";

                // ANCHOR - Generate random book models
                var random = new Random(createdItemName.GetHashCode());

                // Randomize book model
                var bookModelSetKey = GenData.bookModelLib.Keys.ElementAt(
                    (int)Math.Round((GenData.bookModelLib.Count - 1) * (float)random.NextDouble())
                );
                if (!state.LinkCache.TryResolve<IStaticGetter>(bookModelSetKey, out var bookStatic))
                    return;

                // Randomize fragment model
                var bookFragmentModelSetKey = GenData.bookFragmentModelLib.Keys.ElementAt(
                    (int)
                        Math.Round(
                            (GenData.bookFragmentModelLib.Count - 1) * (float)random.NextDouble()
                        )
                );
                if (
                    !state.LinkCache.TryResolve<IStaticGetter>(
                        bookFragmentModelSetKey,
                        out var bookFragmentStatic
                    )
                )
                    return;

                // ANCHOR - Create the schematic
                Book book =
                    new(state.PatchMod)
                    {
                        EditorID = $"{createdItemEditorID}_Schematic",
                        Name = $"{createdItemName} - Part Schematic",
                        Description =
                            $"A schematic describing the process of crafting {aAn}{createdItemName}. I should read this to memorize it — or perhaps I can sell it instead...",
                        Value = 10,
                        Weight = 0.25f,
                        Model = GenData.bookModelLib[bookModelSetKey],
                        InventoryArt = bookStatic.ToNullableLink(),
                        ObjectBounds = bookStatic.ObjectBounds.DeepCopy(),
                        Type = Book.BookType.BookOrTome,
                        PickUpSound = new FormLinkNullable<ISoundDescriptorGetter>(
                            Skyrim.SoundDescriptor.ITMNoteUp.FormKey
                        ),
                        Keywords = new() { Skyrim.Keyword.VendorItemRecipe },
                    };

                state.PatchMod.Books.Set(book);

                // ANCHOR - Create the knowledge "perk" SPELL
                Spell knowledge =
                    new(state.PatchMod)
                    {
                        EditorID = $"{createdItemEditorID}_Knowledge",
                        Name = $"{createdItemName} - Part Knowledge",
                        MenuDisplayObject = book.InventoryArt,
                        ObjectBounds = book.ObjectBounds,
                        EquipmentType = new FormLinkNullable<IEquipTypeGetter>(
                            Skyrim.EquipType.EitherHand.FormKey
                        ),
                        Type = SpellType.Ability,
                        CastType = CastType.ConstantEffect,
                        TargetType = TargetType.Self,
                    };
                state.PatchMod.Spells.Set(knowledge);
                book.Teaches = new BookSpell() { Spell = knowledge.ToLink<ISpellGetter>() };

                // ANCHOR - Create the knowledge "perk" MGEF
                MagicEffect knowledgeMGEF =
                    new(state.PatchMod)
                    {
                        EditorID = $"{createdItemEditorID}_KnowledgeMGEF",
                        Name = $"{createdItemName} - Part Knowledge",
                        MenuDisplayObject = book.InventoryArt,
                        Flags = MagicEffect.Flag.NoMagnitude,
                        CastType = CastType.ConstantEffect,
                        TargetType = TargetType.Self,
                        EquipAbility = new FormLinkNullable<ISpellGetter>(knowledge),
                    };
                if (Settings.HideKnowledgeUI)
                    knowledgeMGEF.Flags |= MagicEffect.Flag.HideInUI;
                state.PatchMod.MagicEffects.Set(knowledgeMGEF);

                knowledge.Effects.Add(
                    new Effect() { BaseEffect = knowledgeMGEF.ToNullableLink(), }
                );

                // ANCHOR - Create the schematic fragments
                Book bookFragment =
                    new(state.PatchMod)
                    {
                        EditorID = $"{book.EditorID}_Fragment",
                        Name = $"{createdItemName} - Part Notes",
                        Description =
                            $"My notes on the crafting process of {aAn}{createdItemName}.¨If I collect a few more I can perhaps combine them into a schematic...",
                        Value = 2,
                        Weight = 0.10f,
                        Model = GenData.bookModelLib[bookModelSetKey],
                        InventoryArt = bookStatic.ToNullableLink(),
                        ObjectBounds = bookStatic.ObjectBounds.DeepCopy(),
                        Type = Book.BookType.BookOrTome,
                        PickUpSound = new FormLinkNullable<ISoundDescriptorGetter>(
                            Skyrim.SoundDescriptor.ITMNoteUp.FormKey
                        ),
                        Keywords = new() { Skyrim.Keyword.VendorItemRecipe },
                    };

                // ANCHOR - Create the COBJs
                // Create COBJ fragment -> book
                var noteToBookCOBJ = state.PatchMod.ConstructibleObjects.AddNew();

                createConversionCOBJs(
                    baseCOBJ: noteToBookCOBJ,
                    ingredientList: new() { bookFragment.ToLink() },
                    result: book.ToLink(),
                    benchKeyword: "Practice",
                    knowledge: knowledge.ToLink(),
                    ingredientCount: 4
                );

                // Create COBJ mats -> fragment
                var matToNoteCOBJ = state.PatchMod.ConstructibleObjects.AddNew();

                createConversionCOBJs(
                    baseCOBJ: matToNoteCOBJ,
                    ingredientList: ingotList,
                    result: bookFragment.ToLink(),
                    benchKeyword: "Practice",
                    knowledge: knowledge.ToLink(),
                    ingredientCount: matReqCount
                );

                // ANCHOR - Save data to lists
                bookKnowledge.Add(
                    knowledge.FormKey,
                    new()
                    {
                        book.FormKey,
                        bookFragment.FormKey,
                        noteToBookCOBJ.FormKey,
                        matToNoteCOBJ.FormKey
                    }
                );

                if (createdItem != null)
                {
                    // Create COBJ item -> book
                    var itemToBookCOBJ = state.PatchMod.ConstructibleObjects.AddNew();

                    createConversionCOBJs(
                        baseCOBJ: itemToBookCOBJ,
                        ingredientList: new() { createdItem },
                        result: book.ToLink(),
                        benchKeyword: "Dismantle",
                        knowledge: knowledge.ToLink(),
                        ingredientCount: 1
                    );

                    // ANCHOR - Add cond to hide from menu if player lacks req perk
                    if (
                        state.LinkCache.TryResolve<IConstructibleObjectGetter>(
                            itemCOBJs[createdItem.FormKey][0],
                            out var initialCOBJ
                        )
                    )
                        foreach (var cond in initialCOBJ.Conditions)
                        {
                            noteToBookCOBJ.Conditions.Add(cond.DeepCopy());
                            itemToBookCOBJ.Conditions.Add(cond.DeepCopy());
                            matToNoteCOBJ.Conditions.Add(cond.DeepCopy());
                        }

                    if (Settings.ShowDebugLogs)
                    {
                        Console.WriteLine($"Created item design perk: {knowledge.Name}");
                        Console.WriteLine($"Created item design book (gives perk): {book.Name}");
                        Console.WriteLine(
                            $"Created item design book fragment (gives book): {bookFragment.Name}"
                        );
                        Console.WriteLine($"-------------------------------");
                    }

                    bookKnowledge[knowledge.FormKey].Add(itemToBookCOBJ.FormKey);
                    // Add to temp list to avoid removal
                    safeToKeepKnowledge.Add(knowledge.FormKey);

                    // Add to req list
                    itemKnowledgeReq[createdItem.FormKey].Add(knowledge.FormKey);
                }
                else
                {
                    if (material.PerkReq != FormLinkGetter<IPerkGetter>.Null)
                    {
                        // Add conditions (so it doesn't clutter the menu)
                        var perkReqCond = new HasPerkConditionData()
                        {
                            RunOnType = Condition.RunOnType.Reference,
                            Reference = Skyrim.PlayerRef,
                        };
                        ;
                        perkReqCond.Perk = new FormLinkOrIndex<IPerkGetter>(
                            perkReqCond,
                            material.PerkReq.FormKey
                        );

                        perkReqCond.Perk.Link.SetTo(material.PerkReq);

                        noteToBookCOBJ.Conditions.Add(
                            new ConditionFloat()
                            {
                                ComparisonValue = 1,
                                CompareOperator = CompareOperator.GreaterThanOrEqualTo,
                                Data = perkReqCond
                            }
                        );

                        matToNoteCOBJ.Conditions.Add(
                            new ConditionFloat()
                            {
                                ComparisonValue = 1,
                                CompareOperator = CompareOperator.GreaterThanOrEqualTo,
                                Data = perkReqCond
                            }
                        );
                    }
                    ;

                    partDict[materialName].Add(partName, knowledge.FormKey);

                    if (Settings.ShowDebugLogs)
                    {
                        Console.WriteLine(
                            $"Created {knowledge.Name}, {book.Name}, and {bookFragment.Name}"
                        );
                    }
                }
            }

            // !SECTION
            // !SECTION
            // SECTION - Initial Prep

            // ANCHOR - Generating 2 menus, one for breaking down items, one for combining the notes into books
            GenerateCustomMenu(
                "Practice",
                "Learn how to combine materials into parts and finished items.",
                Skyrim.Static.BlacksmithWorkbench01.AsNullable(),
                Settings.giveSmithingExp
            );

            GenerateCustomMenu(
                "Dismantle",
                "Learn the make of items by breaking them down.",
                Skyrim.Static.BlacksmithWorkbench01.AsNullable(),
                Settings.giveSmithingExp
            );

            // ANCHOR - Create temporary list with unique values from part list
            foreach (var partEntry in Settings.PartList)
            {
                foreach (var part in partEntry.List)
                {
                    if (!partListUniques.Keys.Contains(part.Name))
                        partListUniques.Add(part.Name, part);
                }
            }

            // ANCHOR - Generate material + part combo schematics early
            foreach (var material in Settings.MaterialWhitelist)
            {
                partDict.Add(material.Key, new());

                foreach (string partName in partListUniques.Keys)
                {
                    string createdItemName = $"{material.Key} {partName}";
                    createSchematicSetup(partName: partName, materialName: material.Key);
                }
            }

            //!SECTION
            //SECTION - Item processing

            Console.WriteLine(string.Empty);
            Console.WriteLine("=================================================");
            Console.WriteLine(string.Empty);
            Console.WriteLine("Identifying parts ...");
            Console.WriteLine(string.Empty);

            foreach (
                IConstructibleObjectGetter baseCOBJ in state
                    .LoadOrder.PriorityOrder.ConstructibleObject()
                    .WinningOverrides()
            )
            {
                // Sanity checks to skip unnecessary processing
                if (
                    baseCOBJ.Items == null
                    || !Settings.BenchSettings.Any(e =>
                        e.Key.FormKey == baseCOBJ.WorkbenchKeyword.FormKey
                    )
                    || !baseCOBJ.CreatedObject.TryResolve(state.LinkCache, out var createdItem)
                    || noValidMats.Contains(createdItem.FormKey)
                    || createdItem is not INamedGetter createdItemName
                    || createdItem is not IKeywordedGetter createdItemKeywords
                    || Settings.ItemBlacklist.Contains(createdItem)
                    || state.PatchMod.ConstructibleObjects.Contains(baseCOBJ)
                )
                    continue;

                // ANCHOR - Check for valid materials and save them to itemMaterials

                if (!itemMaterials.ContainsKey(createdItem.FormKey))
                {
                    if (Settings.ShowDebugLogs)
                    {
                        Console.WriteLine(string.Empty);
                        Console.WriteLine("=======================");
                        Console.WriteLine(string.Empty);
                        Console.WriteLine($"Found new item: {createdItemName.Name}");
                        Console.WriteLine($"Checking for valid materials ...");
                    }
                    foreach (var material in Settings.MaterialWhitelist)
                    {
                        if (createdItemKeywords.Keywords == null)
                            continue;

                        if (
                            createdItemKeywords.Keywords.Any(e =>
                                material.Value.Keywords.Contains(e)
                            )
                            // Jewelry specific check
                            || (
                                createdItemKeywords.Keywords.Contains(Skyrim.Keyword.ArmorJewelry)
                                && baseCOBJ.Items.Any(e =>
                                    e.Item.Item.FormKey == material.Value.Ingot.FormKey
                                )
                            )
                        )
                        {
                            if (!itemMaterials.ContainsKey(createdItem.FormKey))
                            {
                                itemMaterials.Add(createdItem.FormKey, new());
                            }
                            itemMaterials[createdItem.FormKey].Add(material.Key);

                            if (Settings.ShowDebugLogs)
                            {
                                Console.WriteLine($"Found {material.Key}");
                            }
                        }
                    }
                }

                if (itemMaterials.ContainsKey(createdItem.FormKey))
                {
                    if (!itemCOBJs.ContainsKey(createdItem.FormKey))
                        itemCOBJs.Add(createdItem.FormKey, new List<FormKey>());
                    itemCOBJs[createdItem.FormKey].Add(baseCOBJ.FormKey);

                    if (!itemBench.ContainsKey(createdItem.FormKey))
                        itemBench.Add(createdItem.FormKey, baseCOBJ.WorkbenchKeyword.FormKey);

                    if (Settings.ShowDebugLogs)
                    {
                        Console.WriteLine(
                            $"Storing the {baseCOBJ.EditorID} COBJ {createdItemName.Name} connection"
                        );
                    }
                }
                else
                {
                    noValidMats.Add(createdItem.FormKey);
                    if (Settings.ShowDebugLogs)
                    {
                        Console.WriteLine($"No valid materials found, ignoring...");
                    }
                }
            }

            Console.WriteLine($"Found {itemCOBJs.Count} items in total to patch");

            // ANCHOR - Generating design schematic
            Console.WriteLine(string.Empty);
            Console.WriteLine("=================================================");
            Console.WriteLine(string.Empty);
            Console.WriteLine("Generating design blueprints and assigning parts ...");

            foreach (var createdItemFormKey in itemCOBJs.Keys)
            {
                // Pull created item
                if (
                    !state.LinkCache.TryResolve<IItemGetter>(
                        createdItemFormKey,
                        out var createdItem
                    )
                    || createdItem is not INamedGetter createdItemName
                    || createdItemName.Name == null
                    || createdItem is not IKeywordedGetter createdItemKeywords
                )
                    continue;

                if (Settings.ShowDebugLogs)
                {
                    Console.WriteLine(string.Empty);
                    Console.WriteLine("=======================");
                    Console.WriteLine(string.Empty);
                    Console.WriteLine($"Found {createdItemName.Name} ...");
                }
                else
                    Console.WriteLine($"Patching for {createdItemName.Name} ...");

                // creating a new entry in the knowledge req dict to prepare for adding future mats
                itemKnowledgeReq.Add(createdItemFormKey, new());

                // Only create a design blueprint if this is not a basic item
                if (
                    !Settings.BasicItems.Contains(createdItemFormKey)
                    || (
                        createdItemKeywords.Keywords != null
                        && !createdItemKeywords.Keywords.Contains(Skyrim.Keyword.DaedricArtifact)
                    )
                )
                {
                    if (Settings.ShowDebugLogs)
                    {
                        Console.WriteLine($"Generating design schematic ...");
                    }

                    createSchematicSetup(createdItem: createdItem.ToLink());
                }
                else if (Settings.ShowDebugLogs)
                {
                    Console.WriteLine($"Basic item, skipping design schematic");
                    // TODO - Basic item process
                }

                // ANCHOR Assigning the parts
                if (createdItemKeywords.Keywords != null)
                    // loop through all part keywords, eg: light helmet, etc. skip if not valid
                    foreach (var partKey in Settings.PartList)
                    {
                        if (!partKey.Keywords.All(e => createdItemKeywords.Keywords.Contains(e)))
                            continue;

                        foreach (var material in itemMaterials[createdItemFormKey])
                        {
                            foreach (var part in partKey.List)
                            {
                                if (
                                    !createdItemKeywords.Keywords.Contains(
                                        Skyrim.Keyword.DaedricArtifact
                                    )
                                )
                                {
                                    var itemToBookCOBJ =
                                        state.PatchMod.ConstructibleObjects.AddNew();

                                    createConversionCOBJs(
                                        benchKeyword: "Dismantle",
                                        baseCOBJ: itemToBookCOBJ,
                                        ingredientList: new() { createdItem.ToLink() },
                                        ingredientCount: 1,
                                        result: new FormLinkNullable<IConstructibleGetter>(
                                            bookKnowledge[partDict[material][part.Name]][0]
                                        )
                                    );

                                    // Do not show cobjs if lacking skill
                                    if (
                                        state.LinkCache.TryResolve<IConstructibleObjectGetter>(
                                            itemCOBJs[createdItemFormKey][0],
                                            out var initialCOBJ
                                        )
                                    )
                                        foreach (var cond in initialCOBJ.Conditions)
                                        {
                                            itemToBookCOBJ.Conditions.Add(cond.DeepCopy());
                                        }
                                }

                                // Add item to knowledge req
                                itemKnowledgeReq[createdItemFormKey]
                                    .Add(partDict[material][part.Name]);

                                if (Settings.ShowDebugLogs)
                                {
                                    Console.WriteLine($"Found {part.Name}");
                                }

                                // Add to temp list to avoid removal
                                safeToKeepKnowledge.Add(partDict[material][part.Name]);
                            }
                        }
                    }

                foreach (FormKey cobjFormKey in itemCOBJs[createdItemFormKey])
                {
                    // Define COBJ
                    if (
                        !state.LinkCache.TryResolve<IConstructibleObjectGetter>(
                            cobjFormKey,
                            out var cobj
                        )
                    )
                        continue;

                    var modifiedCOBJ = state.PatchMod.ConstructibleObjects.GetOrAddAsOverride(cobj);

                    foreach (var knowledgeFormKey in itemKnowledgeReq[createdItemFormKey])
                    {
                        // Define COBJ
                        if (
                            state.LinkCache.TryResolve<ISpellGetter>(
                                knowledgeFormKey,
                                out var knowledge
                            )
                        )
                            COBJReqKnowledge(modifiedCOBJ, knowledge.ToLink());
                        // TODO - Create book item to give to player with the required knowledge if they don't have Do Not Eat Spell tomes?
                    }
                }
                ;

                // ANCHOR - Patch LVLIs to include schematics

                if (Settings.ShowDebugLogs)
                {
                    Console.WriteLine(string.Empty);
                    Console.WriteLine($"Patching LVLIs to include new schematics ...");
                }

                foreach (FormKey lvliFormKey in LootLVLIWhitelist)
                {
                    // Define LVLI and check if it's empty
                    if (
                        !state.LinkCache.TryResolve<ILeveledItemGetter>(
                            lvliFormKey,
                            out var leveledList
                        )
                        || leveledList.Entries == null
                    )
                        continue;

                    LeveledItem modifiedLVLI = leveledList.DeepCopy();

                    var itemList = modifiedLVLI.Entries;
                    if (itemList == null)
                        continue;

                    int modifiedCount = 0;

                    foreach (var LVLIEntry in itemList)
                    {
                        // Sanity checks to skip unnecessary processing
                        if (LVLIEntry.Data == null || LVLIEntry.Data.Reference == null)
                            continue;

                        if (LVLIEntry.Data.Reference.FormKey != createdItemFormKey)
                            continue;

                        if (!itemLVLIEntries.Keys.Contains(createdItemFormKey))
                        {
                            if (Settings.ShowDebugLogs)
                            {
                                Console.WriteLine($"Creating subLVLI ...");
                            }

                            LeveledItem itemLVLI = state.PatchMod.LeveledItems.AddNew();

                            itemLVLI.ChanceNone = 0;
                            itemLVLI.EditorID =
                                $"{createdItemName.Name.Replace(" ", "")}WithSchematicsLVLI";
                            itemLVLI.Entries = new ExtendedList<LeveledItemEntry>();

                            // add the item first
                            LeveledItemEntry itemEntry = new LeveledItemEntry()
                            {
                                Data = new LeveledItemEntryData()
                                {
                                    Reference = new FormLink<IItemGetter>(createdItem),
                                    Level = 1,
                                    Count = 1
                                }
                            };

                            for (int i = 0; i < 8; i++)
                            {
                                itemLVLI.Entries.Add(itemEntry);
                            }

                            foreach (var spell in itemKnowledgeReq[createdItemFormKey])
                            {
                                // Define LVLI and check if it's empty
                                if (
                                    !state.LinkCache.TryResolve<ISpellGetter>(
                                        spell,
                                        out var knowledge
                                    )
                                )
                                    continue;

                                // basic book entry to be added to schematicLVLI
                                LeveledItemEntry bookEntry = new LeveledItemEntry()
                                {
                                    Data = new LeveledItemEntryData()
                                    {
                                        Reference = new FormLink<IItemGetter>(
                                            bookKnowledge[spell][0]
                                        ),
                                        Level = 1,
                                        Count = 1
                                    }
                                };

                                itemLVLI.Entries.Add(bookEntry);

                                // basic book entry to be added to schematicLVLI
                                LeveledItemEntry bookFragmentEntry = new LeveledItemEntry()
                                {
                                    Data = new LeveledItemEntryData()
                                    {
                                        Reference = new FormLink<IItemGetter>(
                                            bookKnowledge[spell][1]
                                        ),
                                        Level = 1,
                                        Count = 1
                                    }
                                };

                                for (int i = 0; i < 3; i++)
                                {
                                    itemLVLI.Entries.Add(bookFragmentEntry);
                                }
                            }
                            itemLVLIEntries.Add(createdItemFormKey, itemLVLI.FormKey);
                        }

                        if (Settings.ShowDebugLogs)
                        {
                            Console.WriteLine(
                                $"{modifiedLVLI.EditorID}: Found a {LVLIEntry.Data.Count} x lvl {LVLIEntry.Data.Level} {createdItemName.Name} entry"
                            );
                        }

                        modifiedCount++;
                        LVLIEntry.Data.Reference = new FormLink<ILeveledItemGetter>(
                            itemLVLIEntries[createdItemFormKey]
                        );
                    }

                    if (modifiedCount != 0)
                        state.PatchMod.LeveledItems.Set(modifiedLVLI);
                }
            }

            // ANCHOR - Remove unused parts

            Console.WriteLine(string.Empty);
            Console.WriteLine("=================================================");
            Console.WriteLine(string.Empty);
            Console.WriteLine("Cleaning up unused parts ...");

            foreach (var material in Settings.MaterialWhitelist)
            {
                foreach (string partName in partListUniques.Keys)
                {
                    var knowledge = partDict[material.Key][partName];
                    if (!state.LinkCache.TryResolve<ISpellGetter>(knowledge, out var knowledgeRef))
                        continue;

                    if (!safeToKeepKnowledge.Contains(knowledge))
                    {
                        state.PatchMod.Books.Remove(bookKnowledge[knowledge][0]);
                        state.PatchMod.Books.Remove(bookKnowledge[knowledge][1]);
                        state.PatchMod.ConstructibleObjects.Remove(bookKnowledge[knowledge][2]);
                        state.PatchMod.ConstructibleObjects.Remove(bookKnowledge[knowledge][3]);
                        state.PatchMod.MagicEffects.Remove(
                            knowledgeRef.Effects[0].BaseEffect.FormKey
                        );
                        state.PatchMod.Spells.Remove(knowledge);
                        Console.WriteLine($"Removed {material.Key} {partName}");
                    }
                }
            }

            Console.WriteLine(string.Empty);
            Console.WriteLine("=================================================");
            // !SECTION
        }
    }
}
