// Hephaestus.cs
// A mutagen synthesis patcher that randomizes the height of all human COBJs in a deterministic manner
// The patcher can be configured with a minimum and maximum value for each race and gender of that race

using Mutagen.Bethesda;
using Mutagen.Bethesda.FormKeys.SkyrimSE;
using Mutagen.Bethesda.Plugins;
using Mutagen.Bethesda.Plugins.Aspects;
using Mutagen.Bethesda.Skyrim;
using Mutagen.Bethesda.Synthesis;

namespace Hephaestus
{
    public class Program
    {
        static Lazy<Settings> _settings = null!;
        public static Settings settings => _settings.Value;

        public static async Task<int> Main(string[] args)
        {
            // Run the patcher
            return await SynthesisPipeline.Instance
                .AddPatch<ISkyrimMod, ISkyrimModGetter>(RunPatch)
                .SetTypicalOpen(GameRelease.SkyrimSE, "Hephaestus.esp")
                .SetAutogeneratedSettings("Settings", "settings.json", out _settings)
                .Run(args);
        }

        // A method to run the patch on a given load order
        private static void RunPatch(IPatcherState<ISkyrimMod, ISkyrimModGetter> state)
        {
            char[] vowels = { 'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U' };

            Console.WriteLine(String.Empty);
            Console.WriteLine("=================================================");
            Console.WriteLine("Building cache ...");
            Console.WriteLine("=================================================");
            Console.WriteLine(String.Empty);

            // **Main Mechanic**
            // 7. We patch the blacksmithing intro quest to give you the relevant schematics with the materials.

            Dictionary<FormKey, List<FormKey>> itemCOBJs = new();
            Dictionary<FormKey, List<FormKey>> itemLVLIs = new();
            Dictionary<FormKey, FormKey> itemBOOK = new();
            Dictionary<FormKey, Dictionary<String, FormKey>> bookLVLIs = new();
            List<FormKey> benchWhitelist =
                new()
                {
                    Skyrim.Keyword.CraftingSmithingForge.FormKey,
                    Skyrim.Keyword.CraftingCookpot.FormKey,
                    Skyrim.Keyword.CraftingTanningRack.FormKey
                };

            foreach (
                IConstructibleObjectGetter baseCOBJ in state.LoadOrder.PriorityOrder
                    .ConstructibleObject()
                    .WinningOverrides()
            )
            {
                // Sanity checks to lower processing count
                if (
                    baseCOBJ.Items == null
                    || !benchWhitelist.Contains(baseCOBJ.WorkbenchKeyword.FormKey)
                )
                    continue;
                if (
                    !baseCOBJ.CreatedObject.TryResolve(state.LinkCache, out var createdItem)
                    || createdItem is not INamedGetter createdItemName
                    || createdItem is not IWeightValueGetter createdItemValue
                )
                    continue;

                // Base lists to reference
                List<FormKey> LVLIFormList = new List<FormKey>();

                // Check if there are any LVLIs that this item is dropped in
                foreach (
                    var baseLVLI in state.LoadOrder.PriorityOrder.LeveledItem().WinningOverrides()
                )
                {
                    if (baseLVLI.Entries == null)
                        continue;
                    if (baseLVLI.Entries.Any(e => e.Data?.Reference.FormKey == createdItem.FormKey))
                    {
                        if (!itemLVLIs.ContainsKey(createdItem.FormKey))
                            itemLVLIs.Add(createdItem.FormKey, new List<FormKey>());

                        if (!itemLVLIs[createdItem.FormKey].Contains(baseLVLI.FormKey))
                            itemLVLIs[createdItem.FormKey].Add(baseLVLI.FormKey);
                    }
                }

                // if no relevant LVLIs, skip item early
                if (!itemLVLIs.ContainsKey(createdItem.FormKey))
                    continue;

                // add COBJ now since it's already passed the LVLI check
                if (!itemCOBJs.ContainsKey(createdItem.FormKey))
                    itemCOBJs.Add(createdItem.FormKey, new List<FormKey>());
                itemCOBJs[createdItem.FormKey].Add(baseCOBJ.FormKey);
            }

            Console.WriteLine(String.Empty);
            Console.WriteLine("=================================================");
            Console.WriteLine("Assigning item types and prepping things ...");
            Console.WriteLine("=================================================");
            Console.WriteLine(String.Empty);

            foreach (var createdItemFormKey in itemCOBJs.Keys)
            {
                new FormLink<IItemGetter>(createdItemFormKey).TryResolve(
                    state.LinkCache,
                    out var createdItem
                );

                // Sanity checks to lower processing count
                if (
                    createdItem is not INamedGetter createdItemName
                    || createdItem is not IWeightValueGetter createdItemValue
                )
                    continue;

                if (settings.ShowDebugLogs)
                {
                    Console.WriteLine("=================================================");
                    Console.WriteLine(String.Empty);
                    Console.WriteLine($"Found {createdItemName.Name} ...");
                    Console.WriteLine("It's referenced in the following COBJs:");
                    Console.WriteLine($"{String.Join('\n', itemCOBJs[createdItem.FormKey])}");
                    Console.WriteLine("And the following LVLIs:");
                    Console.WriteLine($"{String.Join('\n', itemLVLIs[createdItem.FormKey])}");
                }
                else
                    Console.WriteLine($"Patching for {createdItemName.Name} ...");

                // Deterministic seed
                var random = new Random(createdItem.FormKey.ID.GetHashCode());

                // Base Object
                string? objName = createdItemName.Name;
                string? objEditorID = createdItem.EditorID;
                uint objValue = createdItemValue.Value;
                string? objType = "Misc";

                // Book variables
                Book book;
                var schematicBase = Skyrim.Scroll.EbonyFleshScroll.TryResolve(state.LinkCache);
                var objInvArt = schematicBase?.MenuDisplayObject.TryResolve(state.LinkCache);
                Model objModel = schematicBase?.Model?.DeepCopy() ?? new Model();
                ObjectBounds objBounds =
                    schematicBase?.ObjectBounds?.DeepCopy() ?? new ObjectBounds();
                string? objBench = "Forge";
                string? processName = "crafting";
                string schematicType = "Schematic";
                string? requiredItems = String.Empty;
                string? aAn;
                if (objName?.IndexOfAny(vowels) == 0)
                    aAn = "an";
                else
                    aAn = "a";

                // Assigning item types
                switch (createdItem)
                {
                    case IWeaponGetter:
                        objType = "Weapon";
                        break;
                    case IArmorGetter armorObj:
                        var flagToCheck = armorObj.BodyTemplate;
                        if (flagToCheck == null)
                            continue;
                        switch (flagToCheck.FirstPersonFlags)
                        {
                            case BipedObjectFlag.Hands
                            or BipedObjectFlag.Feet:
                                aAn = "a pair of";
                                break;
                            case BipedObjectFlag.Amulet
                            or BipedObjectFlag.Ring:
                                objType = "Jewelry";
                                break;
                            default:
                                objType = "Armor";
                                break;
                        }
                        if (armorObj.EquipmentType.FormKey == Skyrim.EquipType.Shield.FormKey)
                        {
                            objType = "Shield";
                        }
                        break;
                }
                if (settings.ShowDebugLogs)
                {
                    Console.WriteLine(String.Empty);
                    Console.WriteLine($"Creating {objName} schematics and patching COBJs ...");
                    Console.WriteLine(String.Empty);
                }

                foreach (FormKey cobjFormKey in itemCOBJs[createdItemFormKey])
                {
                    // Define COBJ
                    if (
                        !new FormLink<IConstructibleObjectGetter>(cobjFormKey).TryResolve(
                            state.LinkCache,
                            out var cobj
                        )
                    )
                        continue;

                    // Set values based on bench
                    if (
                        cobj.WorkbenchKeyword.FormKey
                        == Skyrim.Keyword.CraftingSmithingForge.FormKey
                    )
                    {
                        objBench = "Forge";
                        processName = "forging";
                    }
                    else if (
                        cobj.WorkbenchKeyword.FormKey == Skyrim.Keyword.CraftingTanningRack.FormKey
                    )
                    {
                        objBench = "Tanning Rack";
                        processName = "tanning";
                    }
                    else if (
                        cobj.WorkbenchKeyword.FormKey == Skyrim.Keyword.CraftingCookpot.FormKey
                    )
                    {
                        objBench = "Cooking Pot";
                        processName = "cooking";
                        schematicType = "Recipe";
                    }
                    ;

                    if (cobj.Items == null)
                        continue;
                    foreach (var reqItem in cobj.Items)
                    {
                        if (!reqItem.Item.Item.TryResolve(state.LinkCache, out var reqItemObj))
                            continue;
                        if (reqItemObj is not INamedGetter namedItem)
                            continue;
                        requiredItems += $"{namedItem.Name}\n";
                    }
                    ;

                    // Building the flavour text
                    string[] flavourText =
                    {
                        $"looks like the notes of a madman, though I can somewhat decypher it. It seems to detail the process of",
                        $"seems to have been teared off from someone's journal. It seems to explain the process of",
                        $"seems to have been written by an apprentice, from the looks of it it describes the process of",
                        $"goes into great detail on the steps of",
                        $"contains the secrets to",
                        $"is filled with scribbles and notes on the steps of",
                        $"still has some stains of blood on it, it describes the process of"
                    };

                    // Assigning flavour data
                    string bookTextTemplate =
                        $"[pagebreak]\n<p align='center'>\n\n\n{objName} {schematicType}\n\n\n\n</p>\n[pagebreak]\n<p align='left'>\nMaterials needed:\n{requiredItems}\n<img src='img://Textures/Interface/Books/Illuminated_Letters/T_letter.png'>his {schematicType.ToLower()} {flavourText[random.Next(flavourText.Length)]} {processName} {aAn} {objName} at a {objBench}. I better not lose this.";
                    string bookEditorIDTemplate = $"{objEditorID}_{schematicType}";

                    if (!itemBOOK.ContainsKey(createdItem.FormKey))
                    {
                        // create a new book
                        book = state.PatchMod.Books.AddNew(objEditorID);

                        // Set the book properties
                        book.EditorID = $"{objEditorID}_{schematicType}";
                        book.Name = $"{objType} {schematicType}: {objName}";
                        book.Value = objValue * 5;
                        book.Weight = 0.1f;
                        book.Model = objModel;
                        // book.InventoryArt = objInvArt;
                        book.ObjectBounds = objBounds;
                        book.BookText = bookTextTemplate;
                        book.Type = Book.BookType.NoteOrScroll;

                        // Add book to dict
                        itemBOOK.Add(createdItem.FormKey, book.FormKey);

                        if (settings.ShowDebugLogs)
                        {
                            Console.WriteLine($"    Created {book.Name}");
                            Console.WriteLine("-----------------------");
                            Console.WriteLine(book.BookText);
                            Console.WriteLine("-----------------------");
                            Console.WriteLine(String.Empty);
                        }
                    }
                    else
                    {
                        // Link to existing book
                        if (
                            !new FormLink<IBookGetter>(itemBOOK[createdItemFormKey]).TryResolve(
                                state.LinkCache,
                                out var bookLink
                            )
                        )
                            continue;

                        if (bookLink is not Book BookLinkBook)
                            continue;

                        book = BookLinkBook;
                    }

                    // Create a new COBJ record with the modified height and add it to the output mod
                    var modifiedCobj = state.PatchMod.ConstructibleObjects.GetOrAddAsOverride(cobj);
                    GetItemCountConditionData newCond = new GetItemCountConditionData();
                    newCond.ItemOrList = new FormLinkOrIndex<IItemOrListGetter>(
                        newCond,
                        book.FormKey
                    );
                    newCond.ItemOrList.Link.SetTo(book);

                    modifiedCobj.Conditions.Add(
                        new ConditionFloat()
                        {
                            ComparisonValue = 1,
                            CompareOperator = CompareOperator.GreaterThanOrEqualTo,
                            Data = newCond
                        }
                    );

                    if (settings.ShowDebugLogs)
                        Console.WriteLine($"    Patched {cobj.EditorID} with {book.EditorID}");
                }

                if (settings.ShowDebugLogs)
                    Console.WriteLine($"Patching LVLIs to include new schematics ...");

                foreach (FormKey lvliFormKey in itemLVLIs[createdItemFormKey])
                {
                    // Define LVLI and check if it's empty
                    if (
                        !new FormLink<ILeveledItemGetter>(lvliFormKey).TryResolve(
                            state.LinkCache,
                            out var leveledList
                        )
                        && leveledList?.Entries == null
                    )
                        continue;

                    // Define the LVLI to be made specifically for the schematic
                    LeveledItem schematicLVLI;

                    LeveledItemEntry bookEntry = new LeveledItemEntry()
                    {
                        Data = new LeveledItemEntryData()
                        {
                            Reference = new FormLink<IItemGetter>(itemBOOK[createdItemFormKey]),
                            Level = 1,
                            Count = 1
                        }
                    };

                    if (settings.ShowDebugLogs)
                    {
                        Console.WriteLine(String.Empty);
                        Console.WriteLine($"    Patching {leveledList.EditorID}");
                    }

                    for (int i = 0; i < leveledList.Entries?.Count; i++)
                    {
                        var existingEntry = leveledList.Entries[i];
                        if (existingEntry.Data?.Reference.FormKey != createdItem.FormKey)
                            continue;

                        // Get the level of the existing entry
                        short existingLevel = existingEntry?.Data?.Level ?? 1;

                        string leveledItemIDTemplate =
                            $"{objEditorID}_{schematicType}_Lv{existingLevel}";

                        if (!bookLVLIs.ContainsKey(itemBOOK[createdItemFormKey]))
                            bookLVLIs.Add(
                                itemBOOK[createdItemFormKey],
                                new Dictionary<String, FormKey>()
                            );

                        if (
                            !bookLVLIs[itemBOOK[createdItemFormKey]].ContainsKey(
                                leveledItemIDTemplate
                            )
                        )
                        {
                            // Create leveled list for each item with a user customizable drop chance
                            schematicLVLI = state.PatchMod.LeveledItems.AddNew();
                            schematicLVLI.ChanceNone = (byte)(100 - settings.DropChance);
                            schematicLVLI.EditorID = leveledItemIDTemplate;
                            schematicLVLI.Entries = new Noggog.ExtendedList<LeveledItemEntry>();
                            schematicLVLI.Entries.Add(bookEntry);
                            bookLVLIs[itemBOOK[createdItemFormKey]].Add(
                                schematicLVLI.EditorID,
                                schematicLVLI.FormKey
                            );
                        }
                        else
                        {
                            // Link to existing book
                            if (
                                !new FormLink<ILeveledItemGetter>(
                                    bookLVLIs[itemBOOK[createdItemFormKey]][leveledItemIDTemplate]
                                ).TryResolve(state.LinkCache, out var schematicLVLILink)
                            )
                                continue;

                            if (schematicLVLILink is not LeveledItem schematicLVLILinkLVLI)
                                continue;

                            schematicLVLI = schematicLVLILinkLVLI;
                        }

                        // Create a new entry with the new item and the same level
                        LeveledItemEntry newEntry = new LeveledItemEntry()
                        {
                            Data = new LeveledItemEntryData()
                            {
                                Reference = new FormLink<IItemGetter>(schematicLVLI),
                                Level = existingLevel,
                                Count = 1
                            }
                        };

                        LeveledItem modifiedBaseLVLI =
                            state.PatchMod.LeveledItems.GetOrAddAsOverride(leveledList);

                        // Add the new entry to the leveled list
                        if (modifiedBaseLVLI.Entries == null)
                            modifiedBaseLVLI.Entries = new Noggog.ExtendedList<LeveledItemEntry>();
                        modifiedBaseLVLI.Entries.Add(newEntry);

                        if (settings.ShowDebugLogs)
                            Console.WriteLine(
                                $"        Created and inserted {schematicLVLI.EditorID}"
                            );
                    }
                }
            }

            Console.WriteLine(String.Empty);
            Console.WriteLine("=================================================");
        }
    }
}
