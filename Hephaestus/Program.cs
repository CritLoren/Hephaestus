using Mutagen.Bethesda;
using Mutagen.Bethesda.FormKeys.SkyrimSE;
using Mutagen.Bethesda.Plugins;
using Mutagen.Bethesda.Plugins.Aspects;
using Mutagen.Bethesda.Skyrim;
using Mutagen.Bethesda.Synthesis;
using Noggog;

namespace Hephaestus
{
    // To do
    // custom crafting spell to move items around?
    // refactor code, too much duplicated initializations of books, book fragments, conds, etc.

    public class Program
    {
        static Lazy<Settings> _settings = null!;
        public static Settings Settings => _settings.Value;

        public static async Task<int> Main(string[] args)
        {
            // Run the patcher
            return await SynthesisPipeline
                .Instance.AddPatch<ISkyrimMod, ISkyrimModGetter>(RunPatch)
                .SetTypicalOpen(GameRelease.SkyrimSE, "Hephaestus.esp")
                .SetAutogeneratedSettings("Settings", "settings.json", out _settings)
                .Run(args);
        }

        private static void RunPatch(IPatcherState<ISkyrimMod, ISkyrimModGetter> state)
        {
            Dictionary<string, Dictionary<string, FormKey>> partDict = new();
            Dictionary<FormKey, List<FormKey>> bookKnowledge = new();
            Dictionary<FormKey, List<FormKey>> itemCOBJs = new();
            Dictionary<FormKey, List<FormKey>> itemKnowledgeReq = new();
            Dictionary<FormKey, List<string>> itemMaterials = new();
            Dictionary<FormKey, FormKey> itemBench = new();
            List<FormKey> noValidMats = new();
            List<FormKey> safeToKeepKnowledge = new();
            Dictionary<FormKey, FormKey> itemLVLIEntries = new();

            Console.WriteLine(string.Empty);
            Console.WriteLine("=================================================");
            Console.WriteLine(string.Empty);
            Console.WriteLine("Prep phase ...");
            Console.WriteLine(string.Empty);

            // LVLI Whitelist base
            List<FormKey> LootLVLIWhitelist = new();
            LootLVLIWhitelist.AddRange(GenData.LootLVLIWhitelistBase);
            if (Settings.DistributeVendors)
                LootLVLIWhitelist.AddRange(GenData.LootLVLIWhitelistVendor);
            if (Settings.DistributeBlacksmiths)
                LootLVLIWhitelist.AddRange(GenData.LootLVLIWhitelistBlacksmith);
            if (Settings.DistributeSpecial)
                LootLVLIWhitelist.AddRange(GenData.LootLVLIWhitelistSpecial);

            // Generate unique list of parts
            Dictionary<string, PartData> partListUniques = new();
            foreach (var partEntry in Settings.PartList)
            {
                foreach (var part in partEntry.List)
                {
                    if (!partListUniques.Keys.Contains(part.Name))
                        partListUniques.Add(part.Name, part);
                }
            }

            foreach (var material in Settings.MaterialWhitelist)
            {
                partDict.Add(material.Name, new());

                foreach (string partName in partListUniques.Keys)
                {
                    string materialPartName = $"{material.Name} {partName}";
                    string materialPartEditorID = materialPartName.Replace(" ", "");

                    // Deterministic seed
                    var random = new Random(materialPartName.GetHashCode());

                    // Randomize book model
                    var bookModelSetKey = GenData.bookModelLib.Keys.ElementAt(
                        (int)
                            Math.Round(
                                (GenData.bookModelLib.Count - 1) * (float)random.NextDouble()
                            )
                    );
                    if (
                        !state.LinkCache.TryResolve<IStaticGetter>(
                            bookModelSetKey,
                            out var bookStatic
                        )
                    )
                        continue;

                    // Randomize fragment model
                    var bookFragmentModelSetKey = GenData.bookFragmentModelLib.Keys.ElementAt(
                        (int)
                            Math.Round(
                                (GenData.bookFragmentModelLib.Count - 1)
                                    * (float)random.NextDouble()
                            )
                    );
                    if (
                        !state.LinkCache.TryResolve<IStaticGetter>(
                            bookFragmentModelSetKey,
                            out var bookFragmentStatic
                        )
                    )
                        continue;

                    // Create the knowledge "perk"
                    Spell knowledge = state.PatchMod.Spells.AddNew();

                    knowledge.EditorID = $"{materialPartEditorID}Knowledge";
                    knowledge.Name = $"{materialPartName} - Part Knowledge";
                    knowledge.MenuDisplayObject = new FormLinkNullable<IStaticGetter>(bookStatic);
                    knowledge.ObjectBounds = bookStatic.ObjectBounds.DeepCopy();
                    knowledge.EquipmentType = new FormLinkNullable<IEquipTypeGetter>(
                        Skyrim.EquipType.EitherHand.FormKey
                    );
                    knowledge.Type = SpellType.Ability;
                    knowledge.CastType = CastType.ConstantEffect;
                    knowledge.TargetType = TargetType.Self;

                    // Create the knowledge "perk" mgef
                    MagicEffect knowledgeMGEF = state.PatchMod.MagicEffects.AddNew();

                    knowledgeMGEF.EditorID = $"{materialPartEditorID}KnowledgeMGEF";
                    knowledgeMGEF.Name = $"{materialPartName} - Part Knowledge";
                    knowledgeMGEF.MenuDisplayObject = new FormLinkNullable<IStaticGetter>(
                        bookStatic
                    );
                    knowledgeMGEF.Flags.SetFlag(MagicEffect.Flag.NoMagnitude, true);
                    knowledgeMGEF.CastType = CastType.ConstantEffect;
                    knowledgeMGEF.TargetType = TargetType.Self;
                    if (Settings.HideKnowledgeUI)
                        knowledgeMGEF.Flags = MagicEffect.Flag.HideInUI;
                    knowledgeMGEF.EquipAbility = new FormLinkNullable<ISpellGetter>(knowledge);
                    ;

                    knowledge.Effects.Add(
                        new Effect()
                        {
                            BaseEffect = new FormLinkNullable<IMagicEffectGetter>(knowledgeMGEF),
                            Data = new() { Magnitude = 1f }
                        }
                    );

                    // create a new book
                    Book book = state.PatchMod.Books.AddNew();

                    // Set the book properties
                    book.EditorID = $"{materialPartEditorID}Schematic";
                    book.Name = $"{materialPartName} - Part Schematic";
                    book.Description =
                        $"A schematic describing the process of crafting a {materialPartName}. I should read this to memorize it — or perhaps I can sell it instead...";
                    book.Value = 10;
                    book.Weight = 0.25f;
                    book.Model = GenData.bookModelLib[bookModelSetKey];
                    book.InventoryArt = new FormLinkNullable<IStaticGetter>(bookStatic);
                    book.ObjectBounds = bookStatic.ObjectBounds.DeepCopy();
                    book.Type = Book.BookType.BookOrTome;
                    book.PickUpSound = new FormLinkNullable<ISoundDescriptorGetter>(
                        Skyrim.SoundDescriptor.ITMNoteUp.FormKey
                    );
                    book.Keywords = new ExtendedList<IFormLinkGetter<IKeywordGetter>>
                    {
                        Skyrim.Keyword.VendorItemRecipe
                    };
                    book.Teaches = new BookSpell() { Spell = knowledge.ToLink<ISpellGetter>() };

                    // create a new book
                    Book bookFragment = state.PatchMod.Books.AddNew();

                    // Set the book properties
                    bookFragment.EditorID = $"{book.EditorID}Fragment";
                    bookFragment.Name = $"{materialPartName} - Part Notes";
                    bookFragment.Description =
                        $"My notes on the crafting process of a {materialPartName}.¨If I collect a few more I can perhaps combine them into a schematic...";
                    bookFragment.Value = 2;
                    bookFragment.Weight = 0.10f;
                    bookFragment.Model = GenData.bookModelLib[bookModelSetKey];
                    bookFragment.InventoryArt = new FormLinkNullable<IStaticGetter>(bookStatic);
                    bookFragment.ObjectBounds = bookStatic.ObjectBounds.DeepCopy();
                    bookFragment.Type = Book.BookType.BookOrTome;
                    bookFragment.PickUpSound = new FormLinkNullable<ISoundDescriptorGetter>(
                        Skyrim.SoundDescriptor.ITMNoteUp.FormKey
                    );
                    bookFragment.Keywords = new ExtendedList<IFormLinkGetter<IKeywordGetter>>
                    {
                        Skyrim.Keyword.VendorItemRecipe
                    };

                    // Create COBJ fragment -> book
                    var noteToBookCOBJ = state.PatchMod.ConstructibleObjects.AddNew();

                    noteToBookCOBJ.EditorID = $"{materialPartEditorID}Recipe";
                    noteToBookCOBJ.CreatedObject = new FormLinkNullable<IConstructibleGetter>(
                        book.FormKey
                    );

                    noteToBookCOBJ.Items = new ExtendedList<ContainerEntry>
                    {
                        new ContainerEntry()
                        {
                            Item = new ContainerItem()
                            {
                                Item = new FormLink<IItemGetter>(bookFragment.FormKey),
                                Count = 4
                            },
                        }
                    };
                    noteToBookCOBJ.WorkbenchKeyword = new FormLinkNullable<IKeywordGetter>(
                        partListUniques[partName].Bench.FormKey
                    );
                    noteToBookCOBJ.CreatedObjectCount = 1;

                    // Add conditions (so it doesn't clutter the menu)
                    var noteToBookCOBJCond = new GetItemCountConditionData()
                    {
                        RunOnType = Condition.RunOnType.Reference,
                        Reference = Skyrim.PlayerRef,
                    };
                    ;
                    noteToBookCOBJCond.ItemOrList = new FormLinkOrIndex<IItemOrListGetter>(
                        noteToBookCOBJCond,
                        bookFragment.FormKey
                    );

                    noteToBookCOBJCond.ItemOrList.Link.SetTo(bookFragment);

                    noteToBookCOBJ.Conditions.Add(
                        new ConditionFloat()
                        {
                            ComparisonValue = 1,
                            CompareOperator = CompareOperator.GreaterThanOrEqualTo,
                            Data = noteToBookCOBJCond
                        }
                    );

                    // Create COBJ mats -> fragment
                    var matToNoteCOBJ = state.PatchMod.ConstructibleObjects.AddNew();

                    matToNoteCOBJ.EditorID = $"{materialPartEditorID}RecipeFragment";
                    matToNoteCOBJ.CreatedObject = new FormLinkNullable<IConstructibleGetter>(
                        bookFragment.FormKey
                    );

                    matToNoteCOBJ.Items = new ExtendedList<ContainerEntry>
                    {
                        new ContainerEntry()
                        {
                            Item = new ContainerItem()
                            {
                                Item = new FormLink<IItemGetter>(material.Ingot.FormKey),
                                Count = 3 * partListUniques[partName].Size
                            },
                        }
                    };
                    matToNoteCOBJ.WorkbenchKeyword = new FormLinkNullable<IKeywordGetter>(
                        partListUniques[partName].Bench.FormKey
                    );
                    matToNoteCOBJ.CreatedObjectCount = 1;

                    // Add conditions (so it doesn't clutter the menu)
                    var matToNoteCOBJCond = new GetItemCountConditionData()
                    {
                        RunOnType = Condition.RunOnType.Reference,
                        Reference = Skyrim.PlayerRef,
                    };
                    ;
                    matToNoteCOBJCond.ItemOrList = new FormLinkOrIndex<IItemOrListGetter>(
                        matToNoteCOBJCond,
                        material.Ingot.FormKey
                    );
                    matToNoteCOBJCond.ItemOrList.Link.SetTo(material.Ingot.FormKey);

                    matToNoteCOBJ.Conditions.Add(
                        new ConditionFloat()
                        {
                            ComparisonValue = 1,
                            CompareOperator = CompareOperator.GreaterThanOrEqualTo,
                            Data = matToNoteCOBJCond
                        }
                    );

                    // Add conditions (so it doesn't clutter the menu)
                    if (Settings.HideOnceUnlocked)
                    {
                        var knowledgeCondData = new HasSpellConditionData()
                        {
                            RunOnType = Condition.RunOnType.Reference,
                            Reference = Skyrim.PlayerRef,
                        };

                        knowledgeCondData.Spell = new FormLinkOrIndex<ISpellGetter>(
                            knowledgeCondData,
                            knowledge.FormKey
                        );
                        knowledgeCondData.Spell.Link.SetTo(knowledge);

                        var knowledgeCond = new ConditionFloat()
                        {
                            ComparisonValue = 0,
                            CompareOperator = CompareOperator.EqualTo,
                            Data = knowledgeCondData
                        };

                        matToNoteCOBJ.Conditions.Add(knowledgeCond);
                        noteToBookCOBJ.Conditions.Add(knowledgeCond);
                    }

                    // Do not show cobjs if lacking skill
                    if (material.PerkReq != FormLinkGetter<IPerkGetter>.Null)
                    {
                        // Add conditions (so it doesn't clutter the menu)
                        var perkReqCond = new HasPerkConditionData()
                        {
                            RunOnType = Condition.RunOnType.Reference,
                            Reference = Skyrim.PlayerRef,
                        };
                        ;
                        perkReqCond.Perk = new FormLinkOrIndex<IPerkGetter>(
                            perkReqCond,
                            material.PerkReq.FormKey
                        );

                        perkReqCond.Perk.Link.SetTo(material.PerkReq);

                        noteToBookCOBJ.Conditions.Add(
                            new ConditionFloat()
                            {
                                ComparisonValue = 1,
                                CompareOperator = CompareOperator.GreaterThanOrEqualTo,
                                Data = perkReqCond
                            }
                        );

                        matToNoteCOBJ.Conditions.Add(
                            new ConditionFloat()
                            {
                                ComparisonValue = 1,
                                CompareOperator = CompareOperator.GreaterThanOrEqualTo,
                                Data = perkReqCond
                            }
                        );
                    }

                    // Add knowledge spell to part dict then add knowledge and book to separate dict
                    partDict[material.Name].Add(partName, knowledge.FormKey);
                    bookKnowledge.Add(
                        knowledge.FormKey,
                        new()
                        {
                            book.FormKey,
                            bookFragment.FormKey,
                            noteToBookCOBJ.FormKey,
                            matToNoteCOBJ.FormKey
                        }
                    );

                    if (Settings.ShowDebugLogs)
                    {
                        Console.WriteLine(
                            $"Created {knowledge.Name}, {book.Name}, and {bookFragment.Name}"
                        );
                    }
                }
            }

            Console.WriteLine(string.Empty);
            Console.WriteLine("=================================================");
            Console.WriteLine(string.Empty);
            Console.WriteLine("Identifying parts ...");
            Console.WriteLine(string.Empty);

            foreach (
                IConstructibleObjectGetter baseCOBJ in state
                    .LoadOrder.PriorityOrder.ConstructibleObject()
                    .WinningOverrides()
            )
            {
                // Sanity checks to skip unnecessary processing
                if (
                    baseCOBJ.Items == null
                    || !Settings.BenchSettings.Any(e =>
                        e.BenchKeyword.FormKey == baseCOBJ.WorkbenchKeyword.FormKey
                    )
                    || !baseCOBJ.CreatedObject.TryResolve(state.LinkCache, out var createdItem)
                    || noValidMats.Contains(createdItem.FormKey)
                    || createdItem is not INamedGetter createdItemName
                    || createdItem is not IKeywordedGetter createdItemKeywords
                    || Settings.ItemBlacklist.Contains(createdItem)
                    || state.PatchMod.ConstructibleObjects.Contains(baseCOBJ)
                )
                    continue;

                if (!itemMaterials.ContainsKey(createdItem.FormKey))
                {
                    if (Settings.ShowDebugLogs)
                    {
                        Console.WriteLine(string.Empty);
                        Console.WriteLine("=======================");
                        Console.WriteLine(string.Empty);
                        Console.WriteLine($"Found new item: {createdItemName.Name}");
                        Console.WriteLine($"Checking for valid materials ...");
                    }
                    foreach (var material in Settings.MaterialWhitelist)
                    {
                        if (createdItemKeywords.Keywords == null)
                            continue;

                        if (
                            createdItemKeywords.Keywords.Any(e => material.Keywords.Contains(e))
                            // Jewelry specific check
                            || (
                                createdItemKeywords.Keywords.Contains(Skyrim.Keyword.ArmorJewelry)
                                && baseCOBJ.Items.Any(e =>
                                    e.Item.Item.FormKey == material.Ingot.FormKey
                                )
                            )
                        )
                        {
                            if (!itemMaterials.ContainsKey(createdItem.FormKey))
                            {
                                itemMaterials.Add(createdItem.FormKey, new());
                            }
                            itemMaterials[createdItem.FormKey].Add(material.Name);

                            if (Settings.ShowDebugLogs)
                            {
                                Console.WriteLine($"Found {material.Name}");
                            }
                        }
                    }
                }

                if (itemMaterials.ContainsKey(createdItem.FormKey))
                {
                    if (!itemCOBJs.ContainsKey(createdItem.FormKey))
                        itemCOBJs.Add(createdItem.FormKey, new List<FormKey>());
                    itemCOBJs[createdItem.FormKey].Add(baseCOBJ.FormKey);

                    if (!itemBench.ContainsKey(createdItem.FormKey))
                        itemBench.Add(createdItem.FormKey, baseCOBJ.WorkbenchKeyword.FormKey);

                    if (Settings.ShowDebugLogs)
                    {
                        Console.WriteLine(
                            $"Storing the {baseCOBJ.EditorID} COBJ {createdItemName.Name} connection"
                        );
                    }
                }
                else
                {
                    noValidMats.Add(createdItem.FormKey);
                    if (Settings.ShowDebugLogs)
                    {
                        Console.WriteLine($"No valid materials found, ignoring...");
                    }
                }
            }

            Console.WriteLine($"Found {itemCOBJs.Count} items in total to patch");

            Console.WriteLine(string.Empty);
            Console.WriteLine("=================================================");
            Console.WriteLine(string.Empty);
            Console.WriteLine("Generating design blueprints and assigning parts ...");

            foreach (var createdItemFormKey in itemCOBJs.Keys)
            {
                // Pull created item
                if (
                    !state.LinkCache.TryResolve<IItemGetter>(
                        createdItemFormKey,
                        out var createdItem
                    )
                    || createdItem is not INamedGetter createdItemName
                    || createdItemName.Name == null
                    || createdItem is not IKeywordedGetter createdItemKeywords
                )
                    continue;

                string aAn = "a ";
                if (createdItemName.Name.IndexOfAny(GenData.vowels) == 0)
                    aAn = "an ";
                else if (
                    (createdItemFormKey == Skyrim.MiscItem.LeatherStrips.FormKey)
                    || (createdItemFormKey == Skyrim.MiscItem.Leather01.FormKey)
                )
                    aAn = "";

                if (Settings.ShowDebugLogs)
                {
                    Console.WriteLine(string.Empty);
                    Console.WriteLine("=======================");
                    Console.WriteLine(string.Empty);
                    Console.WriteLine($"Found {createdItemName.Name} ...");
                }
                else
                    Console.WriteLine($"Patching for {createdItemName.Name} ...");

                // creating a new entry in the knowledge req dict to prepare for adding future mats
                itemKnowledgeReq.Add(createdItemFormKey, new());

                // Only create a design blueprint if this is not a basic item
                if (
                    !Settings.BasicItems.Contains(createdItemFormKey)
                    || (
                        createdItemKeywords.Keywords != null
                        && !createdItemKeywords.Keywords.Contains(Skyrim.Keyword.DaedricArtifact)
                    )
                )
                {
                    if (Settings.ShowDebugLogs)
                    {
                        Console.WriteLine($"Generating design schematic ...");
                    }

                    string materialPartName = createdItemName.Name;
                    string materialPartEditorID = materialPartName.Replace(" ", "");

                    // Deterministic seed
                    var random = new Random(materialPartName.GetHashCode());

                    // Randomize book model
                    var bookModelSetKey = GenData.bookModelLib.Keys.ElementAt(
                        (int)
                            Math.Round(
                                (GenData.bookModelLib.Count - 1) * (float)random.NextDouble()
                            )
                    );
                    if (
                        !state.LinkCache.TryResolve<IStaticGetter>(
                            bookModelSetKey,
                            out var bookStatic
                        )
                    )
                        continue;

                    // Randomize fragment model
                    var bookFragmentModelSetKey = GenData.bookFragmentModelLib.Keys.ElementAt(
                        (int)
                            Math.Round(
                                (GenData.bookFragmentModelLib.Count - 1)
                                    * (float)random.NextDouble()
                            )
                    );
                    if (
                        !state.LinkCache.TryResolve<IStaticGetter>(
                            bookFragmentModelSetKey,
                            out var bookFragmentStatic
                        )
                    )
                        continue;

                    // Create the knowledge "perk"
                    Spell knowledge = state.PatchMod.Spells.AddNew();

                    knowledge.EditorID = $"{materialPartEditorID}Knowledge";
                    knowledge.Name = $"{materialPartName} - Assembly Knowledge";
                    knowledge.MenuDisplayObject = new FormLinkNullable<IStaticGetter>(bookStatic);
                    knowledge.ObjectBounds = bookStatic.ObjectBounds.DeepCopy();
                    knowledge.EquipmentType = new FormLinkNullable<IEquipTypeGetter>(
                        Skyrim.EquipType.EitherHand.FormKey
                    );
                    knowledge.Type = SpellType.Ability;
                    knowledge.CastType = CastType.ConstantEffect;
                    knowledge.TargetType = TargetType.Self;

                    // Create the knowledge "perk" mgef
                    MagicEffect knowledgeMGEF = state.PatchMod.MagicEffects.AddNew();

                    knowledgeMGEF.EditorID = $"{materialPartEditorID}KnowledgeMGEF";
                    knowledgeMGEF.Name = $"{materialPartName} - Assembly Knowledge";
                    knowledgeMGEF.Description = $"I now know how to craft {materialPartName}";
                    knowledgeMGEF.MenuDisplayObject = new FormLinkNullable<IStaticGetter>(
                        bookStatic
                    );
                    if (Settings.HideKnowledgeUI)
                        knowledgeMGEF.Flags = MagicEffect.Flag.HideInUI;
                    knowledgeMGEF.CastType = CastType.ConstantEffect;
                    knowledgeMGEF.TargetType = TargetType.Self;
                    knowledgeMGEF.EquipAbility = new FormLinkNullable<ISpellGetter>(knowledge);
                    ;

                    knowledge.Effects.Add(
                        new Effect()
                        {
                            BaseEffect = new FormLinkNullable<IMagicEffectGetter>(knowledgeMGEF),
                            Data = new() { Magnitude = 1f }
                        }
                    );

                    // create a new book
                    Book book = state.PatchMod.Books.AddNew();

                    // Set the book properties
                    book.EditorID = $"{materialPartEditorID}Schematic";
                    book.Name = $"{materialPartName} - Assembly Schematic";
                    book.Description =
                        $"A schematic describing the Design of {aAn}{materialPartName}. I should read this to memorize it — or perhaps I can sell it instead...";
                    book.Value = 10;
                    book.Weight = 0.25f;
                    book.Model = GenData.bookModelLib[bookModelSetKey];
                    book.InventoryArt = new FormLinkNullable<IStaticGetter>(bookStatic);
                    book.ObjectBounds = bookStatic.ObjectBounds.DeepCopy();
                    book.Type = Book.BookType.BookOrTome;
                    book.PickUpSound = new FormLinkNullable<ISoundDescriptorGetter>(
                        Skyrim.SoundDescriptor.ITMNoteUp.FormKey
                    );
                    book.Keywords = new ExtendedList<IFormLinkGetter<IKeywordGetter>>
                    {
                        Skyrim.Keyword.VendorItemRecipe
                    };
                    book.Teaches = new BookSpell() { Spell = knowledge.ToLink<ISpellGetter>() };

                    // create a new book
                    Book bookFragment = state.PatchMod.Books.AddNew();

                    // Set the book properties
                    bookFragment.EditorID = $"{book.EditorID}Fragment";
                    bookFragment.Name = $"{materialPartName} - Assembly Notes";
                    bookFragment.Description =
                        $"My notes on the crafting process of {aAn}{materialPartName}.¨If I collect a few more I can perhaps combine them into a schematic...";
                    bookFragment.Value = 2;
                    bookFragment.Weight = 0.10f;
                    bookFragment.Model = GenData.bookModelLib[bookModelSetKey];
                    bookFragment.InventoryArt = new FormLinkNullable<IStaticGetter>(bookStatic);
                    bookFragment.ObjectBounds = bookStatic.ObjectBounds.DeepCopy();
                    bookFragment.Type = Book.BookType.BookOrTome;
                    bookFragment.PickUpSound = new FormLinkNullable<ISoundDescriptorGetter>(
                        Skyrim.SoundDescriptor.ITMNoteUp.FormKey
                    );
                    bookFragment.Keywords = new ExtendedList<IFormLinkGetter<IKeywordGetter>>
                    {
                        Skyrim.Keyword.VendorItemRecipe
                    };

                    // Create COBJ fragment -> book
                    var noteToBookCOBJ = state.PatchMod.ConstructibleObjects.AddNew();

                    noteToBookCOBJ.EditorID = $"{materialPartEditorID}Recipe";
                    noteToBookCOBJ.CreatedObject = new FormLinkNullable<IConstructibleGetter>(
                        book.FormKey
                    );

                    noteToBookCOBJ.Items = new ExtendedList<ContainerEntry>
                    {
                        new ContainerEntry()
                        {
                            Item = new ContainerItem()
                            {
                                Item = new FormLink<IItemGetter>(bookFragment.FormKey),
                                Count = 3
                            },
                        }
                    };
                    noteToBookCOBJ.WorkbenchKeyword = new FormLinkNullable<IKeywordGetter>(
                        itemBench[createdItemFormKey]
                    );
                    noteToBookCOBJ.CreatedObjectCount = 1;

                    // Add conditions (so it doesn't clutter the menu)
                    var noteToBookCOBJCond = new GetItemCountConditionData()
                    {
                        RunOnType = Condition.RunOnType.Reference,
                        Reference = Skyrim.PlayerRef,
                    };
                    ;
                    noteToBookCOBJCond.ItemOrList = new FormLinkOrIndex<IItemOrListGetter>(
                        noteToBookCOBJCond,
                        bookFragment.FormKey
                    );
                    noteToBookCOBJCond.ItemOrList.Link.SetTo(bookFragment);

                    noteToBookCOBJ.Conditions.Add(
                        new ConditionFloat()
                        {
                            ComparisonValue = 1,
                            CompareOperator = CompareOperator.GreaterThanOrEqualTo,
                            Data = noteToBookCOBJCond
                        }
                    );

                    // Breakdown Recipe
                    var itemToBookCOBJ = state.PatchMod.ConstructibleObjects.AddNew();

                    itemToBookCOBJ.EditorID = $"{materialPartEditorID}BreakdownRecipe";
                    itemToBookCOBJ.CreatedObject = new FormLinkNullable<IConstructibleGetter>(book);

                    itemToBookCOBJ.Items = new ExtendedList<ContainerEntry>
                    {
                        new ContainerEntry()
                        {
                            Item = new ContainerItem()
                            {
                                Item = new FormLink<IItemGetter>(createdItemFormKey),
                                Count = 1
                            },
                        }
                    };

                    itemToBookCOBJ.WorkbenchKeyword = new FormLinkNullable<IKeywordGetter>(
                        itemBench[createdItemFormKey]
                    );
                    itemToBookCOBJ.CreatedObjectCount = 1;

                    // Add conditions (so it doesn't clutter the menu)
                    var itemToBookCOBJCond = new GetItemCountConditionData()
                    {
                        RunOnType = Condition.RunOnType.Reference,
                        Reference = Skyrim.PlayerRef,
                    };
                    ;
                    itemToBookCOBJCond.ItemOrList = new FormLinkOrIndex<IItemOrListGetter>(
                        itemToBookCOBJCond,
                        createdItemFormKey
                    );
                    itemToBookCOBJCond.ItemOrList.Link.SetTo(createdItemFormKey);

                    itemToBookCOBJ.Conditions.Add(
                        new ConditionFloat()
                        {
                            ComparisonValue = 1,
                            CompareOperator = CompareOperator.GreaterThanOrEqualTo,
                            Data = itemToBookCOBJCond
                        }
                    );

                    // Create COBJ mats -> fragment
                    var matToNoteCOBJ = state.PatchMod.ConstructibleObjects.AddNew();

                    matToNoteCOBJ.EditorID = $"{materialPartEditorID}RecipeFragment";
                    matToNoteCOBJ.CreatedObject = new FormLinkNullable<IConstructibleGetter>(
                        bookFragment.FormKey
                    );

                    matToNoteCOBJ.Items = new ExtendedList<ContainerEntry>();

                    matToNoteCOBJ.WorkbenchKeyword = new FormLinkNullable<IKeywordGetter>(
                        itemBench[createdItemFormKey]
                    );
                    matToNoteCOBJ.CreatedObjectCount = (ushort?)matToNoteCOBJ.Items.Count;

                    foreach (var materialName in itemMaterials[createdItemFormKey])
                    {
                        var material = Settings.MaterialWhitelist.First(e =>
                            e.Name == materialName
                        );

                        matToNoteCOBJ.Items.Add(
                            new()
                            {
                                Item = new()
                                {
                                    Item = new FormLink<IItemGetter>(material.Ingot.FormKey),
                                    Count = 1
                                }
                            }
                        );

                        // Add conditions (so it doesn't clutter the menu)
                        var matToNoteCOBJCond = new GetItemCountConditionData()
                        {
                            RunOnType = Condition.RunOnType.Reference,
                            Reference = Skyrim.PlayerRef,
                        };
                        ;
                        matToNoteCOBJCond.ItemOrList = new FormLinkOrIndex<IItemOrListGetter>(
                            matToNoteCOBJCond,
                            material.Ingot.FormKey
                        );
                        matToNoteCOBJCond.ItemOrList.Link.SetTo(material.Ingot.FormKey);

                        matToNoteCOBJ.Conditions.Add(
                            new ConditionFloat()
                            {
                                ComparisonValue = 1,
                                CompareOperator = CompareOperator.GreaterThanOrEqualTo,
                                Data = matToNoteCOBJCond
                            }
                        );
                    }

                    // Do not show cobjs if lacking skill
                    if (
                        state.LinkCache.TryResolve<IConstructibleObjectGetter>(
                            itemCOBJs[createdItemFormKey][0],
                            out var initialCOBJ
                        )
                    )
                        foreach (var cond in initialCOBJ.Conditions)
                        {
                            noteToBookCOBJ.Conditions.Add(cond.DeepCopy());
                            itemToBookCOBJ.Conditions.Add(cond.DeepCopy());
                            matToNoteCOBJ.Conditions.Add(cond.DeepCopy());
                        }

                    // Add knowledge spell to part dict then add knowledge and book to separate dict
                    bookKnowledge.Add(
                        knowledge.FormKey,
                        new()
                        {
                            book.FormKey,
                            bookFragment.FormKey,
                            noteToBookCOBJ.FormKey,
                            itemToBookCOBJ.FormKey,
                            matToNoteCOBJ.FormKey
                        }
                    );

                    // Add conditions (so it doesn't clutter the menu)
                    if (Settings.HideOnceUnlocked)
                    {
                        var knowledgeCondData = new HasSpellConditionData()
                        {
                            RunOnType = Condition.RunOnType.Reference,
                            Reference = Skyrim.PlayerRef,
                        };

                        knowledgeCondData.Spell = new FormLinkOrIndex<ISpellGetter>(
                            knowledgeCondData,
                            knowledge.FormKey
                        );
                        knowledgeCondData.Spell.Link.SetTo(knowledge);

                        var knowledgeCond = new ConditionFloat()
                        {
                            ComparisonValue = 0,
                            CompareOperator = CompareOperator.EqualTo,
                            Data = knowledgeCondData
                        };

                        itemToBookCOBJ.Conditions.Add(knowledgeCond);
                        noteToBookCOBJ.Conditions.Add(knowledgeCond);
                        matToNoteCOBJ.Conditions.Add(knowledgeCond);
                    }

                    if (Settings.ShowDebugLogs)
                    {
                        Console.WriteLine($"Created item design perk: {knowledge.Name}");
                        Console.WriteLine($"Created item design book (gives perk): {book.Name}");
                        Console.WriteLine(
                            $"Created item design book fragment (gives book): {bookFragment.Name}"
                        );
                        Console.WriteLine($"-------------------------------");
                    }

                    // Add to req list
                    itemKnowledgeReq[createdItemFormKey].Add(knowledge.FormKey);

                    // Add to temp list to avoid removal
                    safeToKeepKnowledge.Add(knowledge.FormKey);
                }
                else if (Settings.ShowDebugLogs)
                {
                    Console.WriteLine($"Basic item, skipping design schematic");
                }

                // Assigning the parts
                if (createdItemKeywords.Keywords != null)
                    // loop through all part keywords, eg: light helmet, etc. skip if not valid
                    foreach (var partKey in Settings.PartList)
                    {
                        if (!partKey.Keywords.All(e => createdItemKeywords.Keywords.Contains(e)))
                            continue;

                        foreach (var material in itemMaterials[createdItemFormKey])
                        {
                            foreach (var part in partKey.List)
                            {
                                if (
                                    !createdItemKeywords.Keywords.Contains(
                                        Skyrim.Keyword.DaedricArtifact
                                    )
                                )
                                {
                                    var itemToBookCOBJ =
                                        state.PatchMod.ConstructibleObjects.AddNew();

                                    itemToBookCOBJ.EditorID =
                                        $"{createdItemName.Name.Replace(" ", "")}{part.Name.Replace(" ", "")}BreakdownRecipe";
                                    itemToBookCOBJ.CreatedObject =
                                        new FormLinkNullable<IConstructibleGetter>(
                                            bookKnowledge[partDict[material][part.Name]][0]
                                        );

                                    itemToBookCOBJ.Items = new ExtendedList<ContainerEntry>
                                    {
                                        new ContainerEntry()
                                        {
                                            Item = new ContainerItem()
                                            {
                                                Item = new FormLink<IItemGetter>(
                                                    createdItemFormKey
                                                ),
                                                Count = 1
                                            },
                                        }
                                    };
                                    itemToBookCOBJ.WorkbenchKeyword =
                                        new FormLinkNullable<IKeywordGetter>(
                                            itemBench[createdItemFormKey]
                                        );
                                    itemToBookCOBJ.CreatedObjectCount = 1;

                                    // Add conditions (so it doesn't clutter the menu)
                                    var itemToBookCOBJCond = new GetItemCountConditionData()
                                    {
                                        RunOnType = Condition.RunOnType.Reference,
                                        Reference = Skyrim.PlayerRef,
                                    };
                                    ;
                                    itemToBookCOBJCond.ItemOrList =
                                        new FormLinkOrIndex<IItemOrListGetter>(
                                            itemToBookCOBJCond,
                                            createdItemFormKey
                                        );
                                    itemToBookCOBJCond.ItemOrList.Link.SetTo(createdItemFormKey);

                                    itemToBookCOBJ.Conditions.Add(
                                        new ConditionFloat()
                                        {
                                            ComparisonValue = 1,
                                            CompareOperator = CompareOperator.GreaterThanOrEqualTo,
                                            Data = itemToBookCOBJCond
                                        }
                                    );

                                    // Do not show cobjs if lacking skill
                                    if (
                                        state.LinkCache.TryResolve<IConstructibleObjectGetter>(
                                            itemCOBJs[createdItemFormKey][0],
                                            out var initialCOBJ
                                        )
                                    )
                                        foreach (var cond in initialCOBJ.Conditions)
                                        {
                                            itemToBookCOBJ.Conditions.Add(cond.DeepCopy());
                                        }
                                }

                                // Add item to knowledge req
                                itemKnowledgeReq[createdItemFormKey].Add(
                                    partDict[material][part.Name]
                                );

                                if (Settings.ShowDebugLogs)
                                {
                                    Console.WriteLine($"Found {part.Name}");
                                }

                                // Add to temp list to avoid removal
                                safeToKeepKnowledge.Add(partDict[material][part.Name]);
                            }
                        }
                    }

                foreach (FormKey cobjFormKey in itemCOBJs[createdItemFormKey])
                {
                    // Define COBJ
                    if (
                        !state.LinkCache.TryResolve<IConstructibleObjectGetter>(
                            cobjFormKey,
                            out var cobj
                        )
                    )
                        continue;

                    var modifiedCOBJ = state.PatchMod.ConstructibleObjects.GetOrAddAsOverride(cobj);

                    foreach (var knowledge in itemKnowledgeReq[createdItemFormKey])
                    {
                        // Add conditions (so it doesn't clutter the menu)
                        var knowledgeCondData = new HasSpellConditionData()
                        {
                            RunOnType = Condition.RunOnType.Reference,
                            Reference = Skyrim.PlayerRef,
                        };
                        ;
                        knowledgeCondData.Spell = new FormLinkOrIndex<ISpellGetter>(
                            knowledgeCondData,
                            knowledge
                        );
                        knowledgeCondData.Spell.Link.SetTo(knowledge);

                        modifiedCOBJ.Conditions.Add(
                            new ConditionFloat()
                            {
                                ComparisonValue = 1,
                                CompareOperator = CompareOperator.GreaterThanOrEqualTo,
                                Data = knowledgeCondData
                            }
                        );
                    }
                }
                ;

                if (Settings.ShowDebugLogs)
                {
                    Console.WriteLine(string.Empty);
                    Console.WriteLine($"Patching LVLIs to include new schematics ...");
                }

                foreach (FormKey lvliFormKey in LootLVLIWhitelist)
                {
                    // Define LVLI and check if it's empty
                    if (
                        !state.LinkCache.TryResolve<ILeveledItemGetter>(
                            lvliFormKey,
                            out var leveledList
                        )
                        || leveledList.Entries == null
                    )
                        continue;

                    LeveledItem modifiedLVLI = leveledList.DeepCopy();

                    var itemList = modifiedLVLI.Entries;
                    if (itemList == null)
                        continue;

                    int modifiedCount = 0;

                    foreach (var LVLIEntry in itemList)
                    {
                        // Sanity checks to skip unnecessary processing
                        if (LVLIEntry.Data == null || LVLIEntry.Data.Reference == null)
                            continue;

                        if (LVLIEntry.Data.Reference.FormKey != createdItemFormKey)
                            continue;

                        if (!itemLVLIEntries.Keys.Contains(createdItemFormKey))
                        {
                            if (Settings.ShowDebugLogs)
                            {
                                Console.WriteLine($"Creating subLVLI ...");
                            }

                            LeveledItem itemLVLI = state.PatchMod.LeveledItems.AddNew();

                            itemLVLI.ChanceNone = 0;
                            itemLVLI.EditorID =
                                $"{createdItemName.Name.Replace(" ", "")}WithSchematicsLVLI";
                            itemLVLI.Entries = new ExtendedList<LeveledItemEntry>();

                            // add the item first
                            LeveledItemEntry itemEntry = new LeveledItemEntry()
                            {
                                Data = new LeveledItemEntryData()
                                {
                                    Reference = new FormLink<IItemGetter>(createdItem),
                                    Level = 1,
                                    Count = 1
                                }
                            };

                            for (int i = 0; i < 8; i++)
                            {
                                itemLVLI.Entries.Add(itemEntry);
                            }

                            foreach (var spell in itemKnowledgeReq[createdItemFormKey])
                            {
                                // Define LVLI and check if it's empty
                                if (
                                    !state.LinkCache.TryResolve<ISpellGetter>(
                                        spell,
                                        out var knowledge
                                    )
                                )
                                    continue;

                                // basic book entry to be added to schematicLVLI
                                LeveledItemEntry bookEntry = new LeveledItemEntry()
                                {
                                    Data = new LeveledItemEntryData()
                                    {
                                        Reference = new FormLink<IItemGetter>(
                                            bookKnowledge[spell][0]
                                        ),
                                        Level = 1,
                                        Count = 1
                                    }
                                };

                                itemLVLI.Entries.Add(bookEntry);

                                // basic book entry to be added to schematicLVLI
                                LeveledItemEntry bookFragmentEntry = new LeveledItemEntry()
                                {
                                    Data = new LeveledItemEntryData()
                                    {
                                        Reference = new FormLink<IItemGetter>(
                                            bookKnowledge[spell][1]
                                        ),
                                        Level = 1,
                                        Count = 1
                                    }
                                };

                                for (int i = 0; i < 3; i++)
                                {
                                    itemLVLI.Entries.Add(bookFragmentEntry);
                                }
                            }
                            itemLVLIEntries.Add(createdItemFormKey, itemLVLI.FormKey);
                        }

                        if (Settings.ShowDebugLogs)
                        {
                            Console.WriteLine(
                                $"{modifiedLVLI.EditorID}: Found a {LVLIEntry.Data.Count} x lvl {LVLIEntry.Data.Level} {createdItemName.Name} entry"
                            );
                        }

                        modifiedCount++;
                        LVLIEntry.Data.Reference = new FormLink<ILeveledItemGetter>(
                            itemLVLIEntries[createdItemFormKey]
                        );
                    }

                    if (modifiedCount != 0)
                        state.PatchMod.LeveledItems.Set(modifiedLVLI);
                }
            }

            Console.WriteLine(string.Empty);
            Console.WriteLine("=================================================");
            Console.WriteLine(string.Empty);
            Console.WriteLine("Cleaning up unused parts ...");

            foreach (var material in Settings.MaterialWhitelist)
            {
                foreach (string partName in partListUniques.Keys)
                {
                    var knowledge = partDict[material.Name][partName];
                    if (!state.LinkCache.TryResolve<ISpellGetter>(knowledge, out var knowledgeRef))
                        continue;

                    if (!safeToKeepKnowledge.Contains(knowledge))
                    {
                        state.PatchMod.Books.Remove(bookKnowledge[knowledge][0]);
                        state.PatchMod.Books.Remove(bookKnowledge[knowledge][1]);
                        state.PatchMod.ConstructibleObjects.Remove(bookKnowledge[knowledge][2]);
                        state.PatchMod.ConstructibleObjects.Remove(bookKnowledge[knowledge][3]);
                        state.PatchMod.MagicEffects.Remove(
                            knowledgeRef.Effects[0].BaseEffect.FormKey
                        );
                        state.PatchMod.Spells.Remove(knowledge);
                        Console.WriteLine($"Removed {material.Name} {partName}");
                    }
                }
            }

            Console.WriteLine(string.Empty);
            Console.WriteLine("=================================================");
        }
    }
}
